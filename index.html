<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="object-src 'none'; base-uri 'none'; require-trusted-types-for 'script';" />
    <title>Celestial Canvas</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            color: white;
            cursor: none;
        }

        body {
            background-color: #000;
            background-size: 400% 400%;
            animation: gradientAnimation 25s ease infinite;
            transition: background 1s ease, filter 0.5s ease;
        }

        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #cursor-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.06) 0%, rgba(255, 255, 255, 0) 60%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            transition: all 0.2s ease-out;
        }
        
        #cursor-glow.active {
            width: 800px;
            height: 800px;
            background: radial-gradient(circle, var(--glow-color, rgba(255, 255, 255, 0.15)) 0%, rgba(255, 255, 255, 0) 50%);
        }

        #particles-js {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 2;
        }
        
        #particles-js.glow {
            filter: drop-shadow(0 0 3px var(--particle-color)) drop-shadow(0 0 8px var(--particle-color));
        }

        #seed-capture {
            position: fixed;
            bottom: 15px;
            left: 15px;
            z-index: 101;
            background-color: rgba(0,0,0,0.2);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: background-color 0.2s;
        }
        #seed-capture:hover {
            background-color: rgba(0,0,0,0.4);
        }
    </style>
</head>
<body>
    <div id="cursor-glow"></div>
    <div id="particles-js"></div>
    <div id="seed-capture" title="Click to copy seed">Capture Seed</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/particles.js/2.0.0/particles.min.js"></script>
    <script>
        const baseConfig = { "particles": { "number": { "value": 150 }, "color": { "value": "#ffffff" }, "shape": { "type": "circle", "stroke": {"width":0,"color":"#000000"}, "polygon":{"nb_sides":5}, "character": {"value": ["*"], "font": "Verdana", "style": "", "weight": "400"} }, "opacity": { "value": 0.5, "random": true }, "size": { "value": 3, "random": true }, "line_linked": { "enable": false, "distance": 120, "opacity": 0.4 }, "move": { "enable": true, "speed": 4, "direction": "none", "random": false, "straight": false, "out_mode": "out", "attract": { "enable": false }, "trail": {"enable": false, "fillColor": "#000", "length": 10} } }, "interactivity": { "detect_on": "canvas", "events": { "onhover": { "enable": true, "mode": "bubble" }, "resize": true }, "modes": { "bubble": { "distance": 200, "size": 8, "duration": 2 } } }, "retina_detect": true };

        document.addEventListener('DOMContentLoaded', () => {
            const cursorGlow = document.getElementById('cursor-glow');
            const seedCaptureUI = document.getElementById('seed-capture');
            const friction = 0.98;
            let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2, px: 0, py: 0 };
            let isLeftMouseDown = false, isRightMouseDown = false, rightClickUsed = false;
            let tick = 0;
            
            let universeProfile = {};
            let symbioteParticles = [], gravityWells = [], voidPockets = [];
            let orbitalPoint = null, wormhole = { entry: null, exit: null };
            let currentSeed = '';

            // --- Seeding Engine ---
            function mulberry32(a) { return function() { var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
            function stringToSeed(str) { let h=0; for(let i=0;i<str.length;i++){h=(Math.imul(31,h)+str.charCodeAt(i))|0} return h; }
            function generateRandomSeed() { const w1 = ['COSMIC','ASTRAL','VOID','STAR','GALAXY','NEBULA','QUANTUM']; const w2 = ['DRIFT','ECHO','FLARE','PULSE','SONG','CHAOS','VORTEX']; return `${w1[Math.floor(Math.random()*w1.length)]}-${w2[Math.floor(Math.random()*w2.length)]}-${Math.floor(Math.random()*9000)+1000}`; }

            const universeBlueprints = {
                Classical: { left:['comet','void'], right:['supernova','gravityWell'], events:['binaryStars','meteorShower'], aesthetic:{glow:true, trails:false, shape:['circle','star'], physics:{attract:true, straight:false, random:true}} },
                Organic: { left:['symbiote','forceField'], right:['sculptor','setOrbit'], events:['pulsingCore'], aesthetic:{glow:false, trails:true, shape:['circle'], physics:{attract:true, straight:false, random:true}} },
                Digital: { left:['chainLightning','shaper','scribe'], right:['glitch','toggleLinks'], events:['cosmicMessage'], aesthetic:{glow:true, trails:false, shape:['character'], chars:['0','1','<','>','/','?'], physics:{attract:false, straight:true, random:false}} },
                CosmicHorror: { left:['blackHole','symbiote'], right:['invert','anchor'], events:['greatContraction','voidPockets'], aesthetic:{glow:true, trails:false, shape:['edge'], monochrome:true, physics:{attract:false, straight:true, random:false}} },
                Painterly: { left:['alchemist','timeWarp'], right:['toggleTrails','spotlight'], events:['colorShift'], aesthetic:{glow:false, trails:true, shape:['circle'], physics:{attract:false, straight:false, random:true}} }
            };

            const generateUniverseProfile = (pJS, seededRandom) => {
                resetState();
                const blueprintNames = Object.keys(universeBlueprints);
                const blueprintName = blueprintNames[Math.floor(seededRandom() * blueprintNames.length)];
                const blueprint = universeBlueprints[blueprintName];
                const profile = { blueprintName };
                
                profile.leftClickPower = blueprint.left[Math.floor(seededRandom() * blueprint.left.length)];
                profile.rightClickPower = blueprint.right[Math.floor(seededRandom() * blueprint.right.length)];
                profile.ambientEvent = blueprint.events[Math.floor(seededRandom() * blueprint.events.length)];
                
                const baseHue = seededRandom() * 360;
                setRandomGradient(baseHue, blueprint.aesthetic.monochrome, seededRandom);
                const particleColor = hslToHex((baseHue + 180) % 360, 80, 70);
                pJS.particles.color.value = particleColor;
                document.documentElement.style.setProperty('--particle-color', particleColor);
                document.querySelector('#particles-js').classList.toggle('glow', !!blueprint.aesthetic.glow);

                pJS.particles.move.trail.enable = !!blueprint.aesthetic.trails;
                pJS.particles.shape.type = blueprint.aesthetic.shape;
                if(pJS.particles.shape.type === 'character') pJS.particles.shape.character.value = blueprint.aesthetic.chars;

                pJS.particles.number.value = blueprintName === 'Teeming' ? 300 : 150;
                pJS.particles.move.speed = 2 + seededRandom() * 4;
                pJS.particles.move.attract.enable = blueprint.aesthetic.physics.attract && seededRandom() < 0.5;
                pJS.particles.move.straight = blueprint.aesthetic.physics.straight;
                pJS.particles.move.random = blueprint.aesthetic.physics.random;
                pJS.particles.line_linked.enable = blueprintName === 'Digital' || profile.leftClickPower === 'chainLightning' || profile.leftClickPower === 'conductor';
                
                if (profile.ambientEvent === 'voidPockets') { for(let i=0;i<3;i++) voidPockets.push({x:seededRandom()*window.innerWidth, y:seededRandom()*window.innerHeight, r:100+seededRandom()*100}); }
                if (profile.ambientEvent === 'binaryStars') { gravityWells.push({x:window.innerWidth*0.25, y:window.innerHeight*0.5, strength:0.1}, {x:window.innerWidth*0.75, y:window.innerHeight*0.5, strength:0.1}); }
                
                universeProfile = profile;
                pJS.fn.particlesRefresh();
            };

            particlesJS('particles-js', baseConfig);
            const pJS = window.pJSDom[0].pJS;
            
            const urlParams = new URLSearchParams(window.location.search);
            currentSeed = urlParams.get('seed') || generateRandomSeed();
            
            const seededRandom = mulberry32(stringToSeed(currentSeed));
            generateUniverseProfile(pJS, seededRandom);
            
            history.replaceState(null, '', `?seed=${currentSeed}`);
            seedCaptureUI.textContent = `Seed: ${currentSeed}`;

            const update = () => {
                tick++;
                pJS.canvas.ctx.clearRect(0, 0, pJS.canvas.w, pJS.canvas.h);

                if (universeProfile.ambientEvent === 'greatContraction') { const scale = 1 - (Math.sin(tick*0.001)*0.5 + 0.5)*0.1; pJS.canvas.ctx.save(); pJS.canvas.ctx.translate(pJS.canvas.w/2*(1-scale), pJS.canvas.h/2*(1-scale)); pJS.canvas.ctx.scale(scale, scale); }
                if (universeProfile.ambientEvent === 'cosmicMessage' && tick === 300) { createMessage(pJS, ['CREATE','CHANGE','FEEL','BECOME'][Math.floor(seededRandom()*4)]); }
                if (universeProfile.ambientEvent === 'colorShift') { const newHue = (tick*0.1)%360; pJS.particles.color.value = hslToHex(newHue, 80, 70); }
                if (universeProfile.ambientEvent === 'pulsingCore' && tick % 180 === 0) { for(const p of pJS.particles.array) { const dx=p.x-window.innerWidth/2; const dy=p.y-window.innerHeight/2; const dist=Math.sqrt(dx*dx+dy*dy)||1; p.vx+=dx/dist*5; p.vy+=dy/dist*5; } }
                if (universeProfile.ambientEvent === 'meteorShower' && tick % 240 === 0 && seededRandom() > 0.5) { createMeteorShower(pJS, seededRandom); }

                for(let i = pJS.particles.array.length - 1; i >= 0; i--) {
                    const p = pJS.particles.array[i];
                    if (!p) continue;
                    
                    let inVoidPocket = false;
                    for(const pocket of voidPockets){ const dx=pocket.x-p.x; const dy=pocket.y-p.y; if(Math.sqrt(dx*dx+dy*dy)<pocket.r){ inVoidPocket=true; break; } }
                    
                    if(!inVoidPocket) {
                        for(const well of gravityWells) { const dx = well.x - p.x; const dy = well.y - p.y; p.vx += dx * well.strength * 0.01; p.vy += dy * well.strength * 0.01; }
                        if(orbitalPoint) { const dx = orbitalPoint.x - p.x; const dy = orbitalPoint.y - p.y; p.vx += dx * 0.005; p.vy += dy * 0.005; }
                        if (isLeftMouseDown) handleLeftClickPower(p, i, pJS);
                        if (isRightMouseDown) handleRightClickPower(p, i, pJS);
                    }

                    p.vx *= friction; p.vy *= friction;
                    
                    if (wormhole.entry && wormhole.exit) { const dx=wormhole.entry.x-p.x; const dy=wormhole.entry.y-p.y; if (Math.sqrt(dx*dx+dy*dy)<20){p.x=wormhole.exit.x;p.y=wormhole.exit.y;p.vx=(seededRandom()-0.5)*5;p.vy=(seededRandom()-0.5)*5;} }
                }
                
                if(universeProfile.leftClickPower === 'symbiote' && isLeftMouseDown) { for(let j=0; j<symbioteParticles.length; j++){ const sp = symbioteParticles[j]; if(!sp) continue; const target = j===0 ? mouse : symbioteParticles[j-1]; sp.vx += (target.x-sp.x)*0.1; sp.vy += (target.y-sp.y)*0.1;} }

                pJS.fn.particlesUpdate();
                pJS.fn.particlesDraw();
                if (universeProfile.ambientEvent === 'greatContraction') { pJS.canvas.ctx.restore(); }
                requestAnimationFrame(update);
            };
            requestAnimationFrame(update);

            function handleLeftClickPower(p, i, pJS) {
                const dx = mouse.x - p.x; const dy = mouse.y - p.y; const dist = Math.sqrt(dx*dx+dy*dy) || 1;
                switch(universeProfile.leftClickPower) {
                    case 'comet': p.vx += dx * 0.05; p.vy += dy * 0.05; break;
                    case 'void': if (dist < 200) { const force = -1 / dist; p.vx += dx * force; p.vy += dy * force; } break;
                    case 'blackHole': if(dist < 200) { p.vx += dx * 0.1; p.vy += dy * 0.1; } if (dist < 10) pJS.particles.array.splice(i, 1); break;
                    case 'scribe': if(dist < 50 && Math.random() > 0.8) { const pNew = pJS.fn.modes.pushParticles(1, mouse)[0]; if(pNew) { pNew.shape='character'; pNew.character = pJS.particles.shape.character; } } break;
                    case 'shaper': if(dist < 150) { const angle=Math.atan2(dy,dx); p.vx += Math.cos(angle+1.57)*2 - dx*0.01; p.vy += Math.sin(angle+1.57)*2 - dy*0.01; } break;
                    case 'conductor': if(dist<200){pJS.particles.line_linked.opacity=Math.min(1,pJS.particles.line_linked.opacity+0.01);p.vx+=dx*0.01;}break;
                    case 'forceField': if (dist < 100) { p.vx = dx/dist * 10; p.vy = dy/dist * 10; } break;
                    case 'solarFlare': const angle=Math.atan2(dy,dx); const mouse_angle=Math.atan2(mouse.y-mouse.py, mouse.x-mouse.px)||0; if(Math.abs(angle-mouse_angle)<0.5 && dist < 300){p.vx+=Math.cos(mouse_angle)*2; p.vy+=Math.sin(mouse_angle)*2;} break;
                    case 'chainLightning': if(dist < 100 && Math.random() > 0.95) { const n = pJS.particles.array[Math.floor(Math.random()*pJS.particles.array.length)]; if(!n) return; pJS.canvas.ctx.beginPath();pJS.canvas.ctx.moveTo(p.x,p.y);pJS.canvas.ctx.lineTo(n.x,n.y);pJS.canvas.ctx.strokeStyle=p.color.value;pJS.canvas.ctx.stroke(); } break;
                    case 'timeWarp': if(dist < 150) { p.vx *= 0.8; p.vy *= 0.8; } break;
                    case 'symbiote': if(dist < 50 && !symbioteParticles.includes(p)) symbioteParticles.push(p); break;
                    case 'pulsar': if (tick % 30 === 0 && dist < 300) { const force = 20/dist; p.vx-=dx*force; p.vy-=dy*force; } break;
                    case 'alchemist': if(dist < 100) p.color.value = hslToHex(Math.random()*360, 80, 70); break;
                }
            }

            function handleRightClickPower(p, pJS) {
                const dx=mouse.x-p.x; const dy=mouse.y-p.y; const dist=Math.sqrt(dx*dx+dy*dy)||1;
                if(rightClickUsed) return;
                switch(universeProfile.rightClickPower) {
                    case 'glitch': pJS.particles.array.forEach(pt => { pt.x+=(Math.random()-0.5)*50; pt.y+=(Math.random()-0.5)*50; }); rightClickUsed=true; break;
                    case 'invert': document.body.style.filter = 'invert(1)'; rightClickUsed=true; break;
                    case 'spotlight': p.opacity_bubble = dist > 250 ? 0.1 : 1; break;
                    case 'toggleTrails': pJS.particles.move.trail.enable = !pJS.particles.move.trail.enable; pJS.fn.particlesRefresh(); rightClickUsed=true; break;
                    case 'supernova': if(!p.exploded) { p.vx=(Math.random()-0.5)*50; p.vy=(Math.random()-0.5)*50; p.exploded=true; } break;
                    case 'anchor': pJS.particles.array.forEach(pt => { pt.vx=0; pt.vy=0; }); rightClickUsed = true; break;
                    case 'sculptor': if(dist < 100 && p.radius > 0.5) p.radius -= 0.1; break;
                    case 'toggleLinks': pJS.particles.line_linked.enable = !pJS.particles.line_linked.enable; rightClickUsed = true; break;
                }
            }
            
            seedCaptureUI.addEventListener('click', () => {
                navigator.clipboard.writeText(window.location.href).then(() => {
                    seedCaptureUI.textContent = 'Copied!';
                    setTimeout(() => seedCaptureUI.textContent = `Seed: ${currentSeed}`, 2000);
                });
            });

            window.addEventListener('mousemove', e => { mouse.px=mouse.x; mouse.py=mouse.y; mouse.x=e.clientX; mouse.y=e.clientY; cursorGlow.style.left=`${e.clientX}px`; cursorGlow.style.top=`${e.clientY}px`; });
            window.addEventListener('contextmenu', e => e.preventDefault());
            window.addEventListener('mousedown', e => {
                if (e.button === 0) { isLeftMouseDown = true; if (universeProfile.rightClickPower === 'wormhole') { wormhole.entry = { ...mouse }; } } 
                else if (e.button === 2) { 
                    isRightMouseDown = true; 
                    if (universeProfile.rightClickPower === 'supernova') for(const p of pJS.particles.array) p.exploded = false;
                    if (universeProfile.rightClickPower === 'setOrbit') orbitalPoint = { ...mouse };
                    if (universeProfile.rightClickPower === 'wormhole') { wormhole.exit = { ...mouse }; wormhole.entry = null; }
                    if (universeProfile.rightClickPower === 'gravityWell') gravityWells.push({ x: mouse.x, y: mouse.y, strength: 0.1 });
                }
                const glowColor = universeProfile.leftClickPower === 'void' || universeProfile.leftClickPower === 'blackHole' ? 'rgba(255, 100, 100, 0.2)' : 'rgba(255, 255, 255, 0.15)';
                document.documentElement.style.setProperty('--glow-color', glowColor);
                cursorGlow.classList.add('active');
            });
            window.addEventListener('mouseup', e => {
                if (e.button === 0) isLeftMouseDown = false;
                else if (e.button === 2) { isRightMouseDown = false; rightClickUsed = false; document.body.style.filter = ''; pJS.particles.array.forEach(p => p.opacity_bubble = p.opacity.value); }
                cursorGlow.classList.remove('active');
                symbioteParticles = [];
            });
            
            function resetState(){ symbioteParticles=[]; gravityWells=[]; voidPockets=[]; persistentLinks=[]; orbitalPoint=null; wormhole={entry:null,exit:null}; document.body.style.filter=''; tick=0; }
            function createMeteorShower(pJS, seededRandom) { const count=30,angle=seededRandom()*2*Math.PI,speed=seededRandom()*20+20; const startX=window.innerWidth/2-Math.cos(angle)*(window.innerWidth/2+100); const startY=window.innerHeight/2-Math.sin(angle)*(window.innerHeight/2+100); for(let i=0;i<count;i++){setTimeout(()=>{let p=pJS.fn.modes.pushParticles(1,{x:startX+(seededRandom()-0.5)*200,y:startY+(seededRandom()-0.5)*200})[0];if(p){p.vx=Math.cos(angle)*speed;p.vy=Math.sin(angle)*speed;}},i*20);} }
            function createMessage(pJS, message) { const fontSize=100,canvas=document.createElement('canvas'),ctx=canvas.getContext('2d'); ctx.font=`${fontSize}px Arial`; canvas.width=ctx.measureText(message).width; canvas.height=fontSize; ctx.font=`${fontSize}px Arial`; ctx.fillStyle="#FFF"; ctx.fillText(message,0,fontSize*0.8); const data=ctx.getImageData(0,0,canvas.width,canvas.height).data; const startX=window.innerWidth/2-canvas.width/2; const startY=window.innerHeight/2-canvas.height/2; pJS.fn.particlesEmpty(); for(let y=0;y<canvas.height;y+=4){for(let x=0;x<canvas.width;x+=4){if(data[(x+y*canvas.width)*4+3]>128){pJS.fn.modes.pushParticles(1,{x:startX+x,y:startY+y});}}} }
            function setRandomGradient(hue, isMonochrome, seededRandom) { const angle=Math.floor(seededRandom()*360); if(isMonochrome){document.body.style.background=`linear-gradient(${angle}deg, hsl(${hue}, 80%, 10%), hsl(${hue}, 40%, 20%), hsl(${hue}, 90%, 5%))`;}else{document.body.style.background=`linear-gradient(${angle}deg, hsl(${hue},80%,30%), hsl(${(hue+120)%360},80%,20%), hsl(${(hue+240)%360},80%,25%))`;} document.body.style.backgroundSize='400% 400%'; }
            function hslToHex(h,s,l){s/=100;l/=100;let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2,r=0,g=0,b=0;if(h<60){r=c;g=x}else if(h<120){r=x;g=c}else if(h<180){g=c;b=x}else if(h<240){g=x;b=c}else if(h<300){r=x;b=c}else{r=c;b=x}r=Math.round((r+m)*255).toString(16).padStart(2,'0');g=Math.round((g+m)*255).toString(16).padStart(2,'0');b=Math.round((b+m)*255).toString(16).padStart(2,'0');return`#${r}${g}${b}`; }
        });
    </script>
</body>
</html>
