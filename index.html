<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="object-src 'none'; base-uri 'none'; require-trusted-types-for 'script';" />
    <title>Celestial Canvas</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            color: white;
            cursor: none;
        }

        body {
            background-color: #000;
            transition: background 1s ease, filter 0.5s ease;
        }
        
        body::after {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            box-shadow: inset 0 0 15vw rgba(0,0,0,0.5);
            z-index: 102;
            transition: box-shadow 1s ease;
        }

        body.cataclysm-bleed {
            background: #fdfdfd !important;
        }
        body.cataclysm-bleed::after {
            box-shadow: none;
        }


        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 2s cubic-bezier(0.76, 0, 0.24, 1), filter 1s ease, opacity 2s ease;
            background-size: 400% 400%;
            animation: gradientAnimation 30s ease infinite;
        }

        .shake {
            animation: shake 0.82s cubic-bezier(.36,.07,.19,.97) both infinite;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #cursor-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.06) 0%, rgba(255, 255, 255, 0) 60%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            transition: all 0.2s ease-out;
            animation: cursorBreathe 4s ease-in-out infinite;
        }
        
        #cursor-glow.active {
            width: 800px;
            height: 800px;
            background: radial-gradient(circle, var(--glow-color, rgba(255, 255, 255, 0.15)) 0%, rgba(255, 255, 255, 0) 50%);
            animation: none;
        }
        
        @keyframes cursorBreathe {
            0% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
            100% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); }
        }

        #particles-js {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 2;
        }

        #ui-container {
            position: fixed;
            bottom: 15px;
            left: 15px;
            z-index: 101;
            background-color: rgba(0,0,0,0.2);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.5s, transform 0.5s;
            opacity: 0;
            min-width: 220px;
            transform: translateY(10px);
        }
        #ui-container.visible {
            opacity: 0.8;
            transform: translateY(0);
        }
        #ui-container:hover {
            opacity: 1 !important;
        }
        #seed-capture {
            cursor: pointer;
            font-weight: bold;
            margin-top: 5px;
            display: block;
        }
        #seed-capture:hover {
            text-decoration: underline;
        }
        #mutator-display, #anomaly-display {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }
        #energy-bar-container {
            width: 100%;
            height: 3px;
            background-color: rgba(255,255,255,0.1);
            margin-top: 8px;
            border-radius: 3px;
        }
        #energy-bar {
            width: 0%;
            height: 100%;
            background-color: #ff8a8a;
            border-radius: 3px;
            transition: width 0.2s ease-out, background-color 0.5s ease;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="particles-js"></div>
    </div>
    <div id="cursor-glow"></div>
    
    <div id="ui-container">
        <div id="blueprint-display"></div>
        <div id="seed-capture" title="Click to copy shareable URL"></div>
        <div id="mutator-display"></div>
        <div id="anomaly-display"></div>
        <div id="energy-bar-container">
            <div id="energy-bar"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/particles.js/2.0.0/particles.min.js"></script>
    <script>
        const baseConfig = { "particles": { "number": { "value": 150, "density": { "enable": true, "value_area": 800 } }, "color": { "value": "#ffffff" }, "shape": { "type": "circle", "polygon": {"nb_sides": 5}, "character": {"value": ["*"]} }, "opacity": { "value": 0.5, "random": true }, "size": { "value": 3, "random": true }, "line_linked": { "enable": false }, "move": { "enable": true, "speed": 4, "direction": "none", "straight": false, "out_mode": "out", "attract": { "enable": false }, "trail": {"enable": false, "fillColor": "#000", "length": 10} } }, "interactivity": { "detect_on": "canvas", "events": { "onhover": { "enable": true, "mode": "bubble" }, "resize": true }, "modes": { "bubble": { "distance": 200, "size": 8, "duration": 2 } } }, "retina_detect": true };

        document.addEventListener('DOMContentLoaded', () => {
            // UI Elements & State
            const ui = {
                body: document.body,
                cursorGlow: document.getElementById('cursor-glow'),
                container: document.getElementById('ui-container'),
                blueprint: document.getElementById('blueprint-display'),
                seed: document.getElementById('seed-capture'),
                mutators: document.getElementById('mutator-display'),
                anomaly: document.getElementById('anomaly-display'),
                canvasContainer: document.getElementById('canvas-container'),
                energyBar: document.getElementById('energy-bar')
            };
            let friction = 0.98;
            let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            let isLeftMouseDown = false, isRightMouseDown = false;
            let tick = 0;
            
            // Universe State
            let universeState = { energy: 0, state: 'Stable' };
            let universeProfile = {};
            let gravityWells = [], stasisFields = [], phaseZones = [], echoPulses = [], wormholes = [], activeChords = [];
            let pulsars = [], nebulas = [], blackHoles = [], whiteHoles = [], cosmicStrings = [], quasars = [], spacetimeRifts = [];
            let gravityPockets = [], timeDilationZones = [], entangledGroups = [];
            let currentSeed = '', cataclysmInProgress = false, isInitialLoad = true;
            let activeIntervals = [], seedCopyTimeout;

            // --- Seeding Engine ---
            function mulberry32(a) { return function() { var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
            function stringToSeed(str) { let h=0; for(let i=0;i<str.length;i++){h=(Math.imul(31,h)+str.charCodeAt(i))|0} return h; }
            function generateRandomSeed() { const w1 = ['COSMIC','ASTRAL','VOID','STAR','CHRONO','PHANTOM','CRYSTAL','DEEPSEA','BIO', 'AETHER', 'SONIC', 'QUANTUM', 'GARDEN', 'MELODY']; const w2 = ['DRIFT','ECHO','FLARE','PULSE','SONG','WARP','VORTEX','SHARD','CURRENT','SPORE', 'VEIL', 'HUM', 'FOAM', 'INK', 'BLOOM', 'NOTE']; return `${w1[Math.floor(Math.random()*w1.length)]}-${w2[Math.floor(Math.random()*w2.length)]}-${Math.floor(Math.random()*9000)+1000}`; }

            // --- Blueprint & Mutator Systems ---
            const universeBlueprints = {
                Classical: { left:['comet'], right:['supernova','gravityWell'], events:['binaryStars','meteorShower'], cataclysms:['Supernova'], aesthetic:{glow:true, trails:false, shape:['circle','star'], physics:{attract:true, straight:false, bounce:false, friction:0.98}} },
                Organic: { left:['symbiote','forceField'], right:['sculptor','setOrbit'], events:['pulsingCore', 'sporeRelease'], cataclysms:['Phase Shift'], aesthetic:{glow:false, trails:true, shape:['circle'], physics:{attract:true, straight:false, bounce:false, friction:0.98}} },
                Digital: { left:['chainLightning','shaper','scribe'], right:['glitch','toggleLinks'], events:['cosmicMessage'], cataclysms:['Glitch Storm'], aesthetic:{glow:true, trails:false, shape:['character'], chars:['0','1','<','>','/','?'], physics:{attract:false, straight:true, bounce:false, friction:0.98}} },
                Crystalline: { left: ['shatter', 'refractor'], right: ['crystalize', 'glaze'], events: ['crystalGrowth'], cataclysms: ['Resonance Cascade'], aesthetic:{glow:true, trails:false, shape:['triangle', 'edge'], physics:{attract:false, straight:true, bounce:true, friction:1}} },
                BioMechanical: { left: ['infect', 'tendril'], right: ['harvest', 'toggleLinks'], events: ['neuronPulse', 'sporeRelease'], cataclysms: ['Overgrowth'], aesthetic:{glow:true, trails:true, shape:['polygon'], physics:{attract:true, straight:false, bounce:true, friction:0.96}} },
                ChronoVerse: { left: ['accelerate'], right: ['stasisField'], events: ['temporalEchoes'], cataclysms: ['Time Collapse'], aesthetic:{glow:true, trails:true, shape:['circle'], physics:{attract:false, straight:false, bounce:false, friction:0.97}} },
                VoidTouched: { left: ['voidRift','void'], right: ['unravel'], events: ['flickeringReality'], cataclysms: ['Total Annihilation', 'Entropic Heat Death'], aesthetic:{glow:true, trails:false, shape:['circle', 'edge'], monochrome:true, physics:{attract:true, straight:true, bounce:false, friction:0.98}} },
                PhantomEcho: { left: ['echoPulse'], right: ['phaseZone'], events: ['dejaVu'], cataclysms: ['Causality Collapse'], aesthetic:{glow:true, trails:false, shape:['circle'], physics:{attract:false, straight:false, bounce:false, friction:0.97}} },
                Aetherial: { left: ['whisper', 'fade'], right: ['paint', 'wormhole'], events: ['aurora'], cataclysms: ['Great Fading'], aesthetic:{glow:true, trails:true, shape:['circle'], opacity: 0.3, physics:{attract:false, straight:false, bounce:false, friction:0.99}}},
                QuantumFoam: { left: ['observe', 'quantumTunnel'], right: ['entangle', 'decohere'], events: ['probabilityFlux'], cataclysms: ['False Vacuum Decay'], aesthetic:{glow:true, trails:false, shape:['edge', 'triangle'], physics:{attract:false, straight:true, bounce:true, friction:0.99}} },
                SonicScapes: { left: ['resonate', 'dampen'], right: ['shockwave', 'silence'], events: ['ambientHum'], cataclysms: ['The Great Silence'], aesthetic:{glow:true, trails:true, shape:['edge'], opacity: 0.6, physics:{attract:false, straight:false, bounce:true, friction:0.97}} },
                LivingInk: { left: ['smudge', 'draw'], right: ['splatter', 'blot'], events: ['inkSeep'], cataclysms: ['The Bleed'], aesthetic:{glow:false, trails:true, shape:['circle'], physics:{attract:false, straight:false, bounce:false, friction:0.92}} },
                CosmicGarden: { left: ['tendril', 'spore'], right: ['bloom', 'harvest'], events: ['pollination'], cataclysms: ['Overgrowth', 'The Grand Bloom'], aesthetic:{glow:false, trails:true, shape:['circle', 'polygon'], physics:{attract:true, straight:false, bounce:false, friction:0.94}} },
                MelodyVerse: { left: ['resonate', 'sing'], right: ['shockwave', 'chord'], events: ['ambientHum'], cataclysms: ['The Great Silence', 'The Final Chord'], aesthetic:{glow:true, trails:false, shape:['triangle', 'edge'], physics:{attract:false, straight:false, bounce:true, friction:0.98}} },
                TemporalTapestry: { left: ['accelerate', 'rewind'], right: ['stasisField', 'snapshot'], events: ['temporalEchoes', 'dejaVu'], cataclysms: ['Time Collapse', 'Causality Collapse'], aesthetic:{glow:true, trails:true, shape:['circle'], physics:{attract:false, straight:false, bounce:false, friction:0.96}} },
                ChromaticAberration: { left: ['refractor', 'dampen'], right: ['glitch', 'paint'], events: ['flickeringReality'], cataclysms: ['Glitch Storm'], aesthetic:{glow:true, trails:false, shape:['circle', 'edge'], physics:{attract:false, straight:true, bounce:true, friction:0.99}} }
            };

            const mutators = {
                'Unstable Particles': (pJS) => { /* Handled in update loop */ }, 'Repulsive Field': (pJS) => { /* Handled in update loop */ },
                'Low-Gravity': (pJS) => { friction *= 0.9; }, 'Viscous': (pJS) => { friction = 0.85; },
                'Hyperspeed': (pJS) => { pJS.particles.move.speed *= 2.5; }, 'Magnetic': (pJS) => { pJS.particles.move.attract.enable = true; pJS.particles.move.attract.rotateX = 1200; pJS.particles.move.attract.rotateY = 1200; },
                'Dwarf & Giant': (pJS) => { /* Handled in tagParticles */ }, 'Erratic': (pJS) => { /* Handled in update loop */ },
                'Rainbow': (pJS) => { /* Handled in update loop */ }, 'Pulsing Particles': (pJS) => { /* Handled in update loop */ },
                'Torus Field': (pJS) => { pJS.particles.move.out_mode = 'out'; /* Custom handling */ }, 'Flickering': (pJS) => { /* Handled in update loop */ },
                'Inertialess': (pJS) => { friction = 0.6; }, 'Gravity Pockets': (pJS) => { /* Handled in generateUniverse */ },
                'Time Dilation Fields': (pJS) => { /* Handled in generateUniverse */ },
                'Swarm Behavior': (pJS) => { /* Handled in update loop */ }, 'Color Shifting': (pJS) => { /* Handled in update loop */ },
                'Phase Shifted': (pJS) => { /* Handled in update loop */ }
            };
            
            const anomalies = { 
                'Pulsar': (pJS, r) => { pulsars.push({ x: pJS.canvas.w * (0.3 + r()*0.4), y: pJS.canvas.h * (0.3 + r()*0.4), angle: 0, period: 100 + Math.floor(r()*100), strength: 20 + r()*20 }); }, 
                'Nebula': (pJS, r) => { const hue = r()*360; nebulas.push({ x: pJS.canvas.w * (0.3 + r()*0.4), y: pJS.canvas.h * (0.3 + r()*0.4), radius: 250 + r()*150, color: `hsla(${hue}, 70%, 50%, 0.15)`, baseColor: {h: hue, s: 70, l: 50} }); },
                'Black Hole': (pJS, r) => { blackHoles.push({ x: pJS.canvas.w * (0.2 + r()*0.6), y: pJS.canvas.h * (0.2 + r()*0.6), mass: 150 + r()*150, eventHorizon: 15 + r()*10 }); },
                'White Hole': (pJS, r) => { whiteHoles.push({ x: pJS.canvas.w * (0.2 + r()*0.6), y: pJS.canvas.h * (0.2 + r()*0.6), strength: 5 + r()*5, spawnRate: 0.1 + r()*0.1, tick: 0 }); },
                'Cosmic String': (pJS, r) => { cosmicStrings.push({ x1: pJS.canvas.w * r(), y1: pJS.canvas.h * r(), x2: pJS.canvas.w * r(), y2: pJS.canvas.h * r(), strength: 5 + r()*5 }); },
                'Quasar': (pJS, r) => { quasars.push({ x: pJS.canvas.w * (0.3 + r()*0.4), y: pJS.canvas.h * (0.3 + r()*0.4), angle: r()*Math.PI*2, strength: 40 + r()*40, rotationSpeed: 0.02 + r()*0.03, spawnRate: 0.5 + r()*0.5, tick: 0 }); },
                'Spacetime Rift': (pJS, r) => { const rift = { points: [], strength: 0.5 + r() }; let x = pJS.canvas.w * (0.1 + r()*0.8), y = pJS.canvas.h * (0.1 + r()*0.8); for(let i=0; i<10; i++) { rift.points.push({x,y}); x += (r()-0.5)*100; y += (r()-0.5)*100; } spacetimeRifts.push(rift); }
            };

            const generateUniverse = (pJS, seed) => {
                resetState();
                currentSeed = seed;
                const seededRandom = mulberry32(stringToSeed(seed));
                
                const blueprintNames = Object.keys(universeBlueprints);
                const blueprintName = blueprintNames[Math.floor(seededRandom() * blueprintNames.length)];
                const blueprint = universeBlueprints[blueprintName];
                
                universeProfile = {
                    blueprintName,
                    leftClickPower: blueprint.left[Math.floor(seededRandom() * blueprint.left.length)],
                    rightClickPower: blueprint.right[Math.floor(seededRandom() * blueprint.right.length)],
                    ambientEvent: blueprint.events[Math.floor(seededRandom() * blueprint.events.length)],
                    cataclysm: blueprint.cataclysms[Math.floor(seededRandom() * blueprint.cataclysms.length)],
                    mutators: [],
                    anomaly: null
                };
                
                // Apply Aesthetics & Physics
                const baseHue = seededRandom() * 360;
                setRandomGradient(baseHue, blueprint.aesthetic.monochrome, seededRandom, blueprintName === 'VoidTouched');
                pJS.particles.color.value = hslToHex((baseHue + 180) % 360, 80, 70);
                if (blueprintName === 'CosmicGarden') pJS.particles.color.value = hslToHex(120 + (seededRandom()-0.5)*40, 70, 60);
                pJS.particles.opacity.value = blueprint.aesthetic.opacity || 0.5;
                pJS.particles.number.value = 150; pJS.particles.number.value_max = 400;
                pJS.particles.move.speed = 1 + seededRandom() * 3;
                pJS.particles.move.trail.enable = !!blueprint.aesthetic.trails;
                pJS.particles.shape.type = blueprint.aesthetic.shape;
                if (blueprintName === 'Digital') pJS.particles.shape.character.value = blueprint.aesthetic.chars;
                pJS.particles.line_linked.enable = blueprintName === 'BioMechanical' || blueprintName === 'Digital';
                pJS.particles.move.attract.enable = blueprint.aesthetic.physics.attract;
                pJS.particles.move.straight = blueprint.aesthetic.physics.straight;
                pJS.particles.move.out_mode = blueprint.aesthetic.physics.bounce ? 'bounce' : 'out';
                friction = blueprint.aesthetic.physics.friction;
                
                // Apply Mutators
                const mutatorKeys = Object.keys(mutators);
                const numMutators = seededRandom() > 0.85 ? 2 : (seededRandom() > 0.4 ? 1 : 0);
                while(universeProfile.mutators.length < numMutators) {
                    const mutatorName = mutatorKeys[Math.floor(seededRandom() * mutatorKeys.length)];
                    if (!universeProfile.mutators.includes(mutatorName)) { 
                        universeProfile.mutators.push(mutatorName); 
                        mutators[mutatorName](pJS); 
                        if (mutatorName === 'Gravity Pockets') { for(let i=0; i<3; i++) { gravityPockets.push({ x: pJS.canvas.w * seededRandom(), y: pJS.canvas.h * seededRandom(), strength: (seededRandom() - 0.5) * 0.4, radiusSq: Math.pow(100 + seededRandom() * 100, 2) }); } }
                        if (mutatorName === 'Time Dilation Fields') { for(let i=0; i<2; i++) { timeDilationZones.push({ x: pJS.canvas.w * seededRandom(), y: pJS.canvas.h * seededRandom(), timeFactor: 0.5 + seededRandom() * 1.5, radiusSq: Math.pow(120 + seededRandom() * 100, 2) }); } }
                    }
                }
                
                // Spawn Anomaly
                if (seededRandom() > 0.5) {
                    const anomalyKeys = Object.keys(anomalies);
                    const anomalyName = anomalyKeys[Math.floor(seededRandom() * anomalyKeys.length)];
                    universeProfile.anomaly = anomalyName;
                    anomalies[anomalyName](pJS, seededRandom);
                }

                universeState = { energy: 0, state: 'Stable', maxEnergy: 4000 + seededRandom() * 2000 };
                
                // Update UI
                history.replaceState(null, '', `?seed=${currentSeed}`);
                ui.blueprint.innerText = `Blueprint: ${blueprintName}`;
                ui.seed.innerText = `Seed: ${currentSeed}`;
                ui.mutators.innerText = universeProfile.mutators.length ? `Mutators: ${universeProfile.mutators.join(', ')}` : 'Mutators: None';
                ui.anomaly.innerText = universeProfile.anomaly ? `Anomaly: ${universeProfile.anomaly}` : 'Anomaly: None';
                setTimeout(() => { ui.container.classList.add('visible'); }, 500);

                pJS.fn.particlesRefresh();
                tagParticles(pJS.particles.array);

                if (isInitialLoad) {
                    pJS.particles.array.forEach(p => {
                        p.x = pJS.canvas.w / 2; p.y = pJS.canvas.h / 2;
                        const angle = Math.random()*2*Math.PI; const force = Math.random()*20+5;
                        p.vx = Math.cos(angle)*force; p.vy = Math.sin(angle)*force;
                    });
                    isInitialLoad = false;
                }
            };

            particlesJS('particles-js', baseConfig);
            const pJS = window.pJSDom[0].pJS;
            
            const urlParams = new URLSearchParams(window.location.search);
            generateUniverse(pJS, urlParams.get('seed') || generateRandomSeed());
            
            const update = () => {
                tick++;
                if (cataclysmInProgress) { requestAnimationFrame(update); return; }

                // --- State & Energy Management ---
                const energyDelta = isLeftMouseDown || isRightMouseDown ? 10 : -5;
                universeState.energy = Math.max(0, universeState.energy + energyDelta);
                ui.energyBar.style.width = `${(universeState.energy / universeState.maxEnergy) * 100}%`;
                if (universeState.energy > universeState.maxEnergy * 0.95) ui.energyBar.style.backgroundColor = '#ff4242';
                else if (universeState.energy > universeState.maxEnergy * 0.7) ui.energyBar.style.backgroundColor = '#ff9e42';
                else ui.energyBar.style.backgroundColor = '#ffffff';

                if (universeState.energy >= universeState.maxEnergy && universeState.state !== 'Unstable') {
                    universeState.state = 'Unstable';
                    triggerCataclysm(pJS);
                } else if (universeState.energy > universeState.maxEnergy * 0.9) {
                    ui.canvasContainer.classList.add('shake');
                } else {
                    ui.canvasContainer.classList.remove('shake');
                }
                
                const trailAlpha = pJS.particles.move.trail.enable ? (universeProfile.blueprintName === 'LivingInk' ? 0.2 : 0.1) : 1;
                pJS.canvas.ctx.fillStyle = `rgba(0, 0, 0, ${trailAlpha})`;
                pJS.canvas.ctx.fillRect(0, 0, pJS.canvas.w, pJS.canvas.h);
                    
                const worldMouse = { ...mouse };

                // --- Main Particle Loop ---
                for(let i = pJS.particles.array.length - 1; i >= 0; i--) {
                    const p = pJS.particles.array[i];
                    if (!p) continue;
                    
                    if (p.phasedFrames > 0) p.phasedFrames--;
                    let isPhased = p.phasedFrames > 0;

                    let timeFactor = 1.0;
                    for (const zone of timeDilationZones) { if (Math.pow(p.x-zone.x,2)+Math.pow(p.y-zone.y,2) < zone.radiusSq) { timeFactor = zone.timeFactor; break; } }
                    
                    const updateSteps = timeFactor > 1 ? Math.floor(timeFactor) : 1;
                    for(let step=0; step < updateSteps; step++) {
                        if (timeFactor < 1 && Math.random() > timeFactor) continue;
                    
                        let isStasis = false;
                        for (const zone of phaseZones) { if (Math.pow(p.x - zone.x, 2) + Math.pow(p.y - zone.y, 2) < zone.radiusSq) { isPhased = true; break; } }
                        for (const field of stasisFields) { if (Math.pow(p.x - field.x, 2) + Math.pow(p.y - field.y, 2) < field.r*field.r) { isStasis = true; break; } }

                        // Apply ongoing effects
                        if(p.unravelling > 0) { p.unravelling--; p.radius *= 0.98; if (p.unravelling <= 0) { pJS.particles.array.splice(i,1); continue; } }
                        if(p.isCrystalized || isStasis) { p.vx = 0; p.vy = 0; }
                        if (p.fading > 0) { p.fading--; p.opacity.value = Math.max(0, p.opacity.value - 0.01); if(p.opacity.value <= 0) {pJS.particles.array.splice(i,1); continue;}}
                        if (p.blooming > 0) { p.blooming--; p.radius += 0.2; if (p.blooming <= 0) { pJS.particles.array.splice(i,1); pJS.fn.modes.pushParticles(2 + Math.floor(Math.random()*2), {x:p.x,y:p.y}); continue; }}


                        // Apply Anomalies
                        for (const nebula of nebulas) { const dSq = Math.pow(p.x - nebula.x, 2) + Math.pow(p.y - nebula.y, 2); if (dSq < nebula.radius*nebula.radius) { p.vx *= 0.95; p.vy *= 0.95; if(!p.colorLocked) { const pColor = p.color.rgb; p.color.rgb = { r: (pColor.r*9+nebula.baseColor.h/360*255)/10, g: (pColor.g*9+nebula.baseColor.s/100*255)/10, b: (pColor.b*9+nebula.baseColor.l/100*255)/10 }; } } }
                        for (const pulsar of pulsars) { const angleToP = Math.atan2(p.y-pulsar.y, p.x-pulsar.x); const angleDiff = Math.abs(pulsar.angle - angleToP) % Math.PI; if (angleDiff < 0.1) { p.vx += Math.cos(pulsar.angle) * pulsar.strength * 0.1; p.vy += Math.sin(pulsar.angle) * pulsar.strength * 0.1; }}
                        for (const q of quasars) { const angleToP = Math.atan2(p.y-q.y, p.x-q.x); const angleDiff = Math.abs(q.angle-angleToP)%(Math.PI); if(angleDiff < 0.15){ p.vx += Math.cos(q.angle)*q.strength*0.1; p.vy += Math.sin(q.angle)*q.strength*0.1; } }
                        for (const hole of blackHoles) { const dx = hole.x - p.x, dy = hole.y - p.y, distSq = dx*dx+dy*dy; if(distSq < hole.eventHorizon*hole.eventHorizon) {pJS.particles.array.splice(i,1); continue;} if(distSq < 40000){const force = hole.mass / distSq; p.vx += dx * force; p.vy += dy * force;} }
                        for (const hole of whiteHoles) { const dx = hole.x-p.x, dy = hole.y-p.y, distSq = dx*dx+dy*dy; if (distSq < 90000) { const force = hole.strength / Math.sqrt(distSq); p.vx -= dx*force*0.1; p.vy -= dy*force*0.1; } }

                        // Apply Mutators
                        if (universeProfile.mutators.includes('Pulsing Particles')) { p.radius = p.radius_initial * (1 + 0.5 * Math.sin(tick * 0.05 + p.seed)); }
                        if (universeProfile.mutators.includes('Unstable Particles') && Math.random() < 0.0005) { if (Math.random() > 0.5 && pJS.particles.array.length < pJS.particles.number.value_max) { pJS.fn.modes.pushParticles(1, {x:p.x, y:p.y}); } else { pJS.particles.array.splice(i,1); continue; } }
                        if (universeProfile.mutators.includes('Repulsive Field') && !isPhased) { for(const p2 of pJS.particles.array) { if(p === p2) continue; const dx=p.x-p2.x, dy=p.y-p2.y, distSq=dx*dx+dy*dy; if(distSq < 2500) { p.vx += dx/distSq*2; p.vy += dy/distSq*2; } } }
                        if (universeProfile.mutators.includes('Erratic')) { p.vx += (Math.random()-0.5)*0.3; p.vy += (Math.random()-0.5)*0.3; }
                        if (universeProfile.mutators.includes('Rainbow') && !p.colorLocked) { p.color = { rgb: { r: 127*(1+Math.sin(tick*0.05 + p.x*0.01)), g: 127*(1+Math.sin(tick*0.05 + p.y*0.01)), b: 127*(1+Math.sin(tick*0.05)) } }; }
                        if (universeProfile.mutators.includes('Color Shifting') && !p.colorLocked) { const speed = Math.min(1, Math.sqrt(p.vx*p.vx + p.vy*p.vy) / 10); const hue = (tick + p.seed)%360; p.color.rgb = hexToRgb(hslToHex(hue, 80, 50 + speed*25)); }
                        if (universeProfile.mutators.includes('Phase Shifted') && Math.random() < 0.0002) { p.phasedFrames = 60 + Math.floor(Math.random()*60); }
                        if (universeProfile.mutators.includes('Flickering')) { if(tick % Math.floor(20+p.seed*20) === 0) p.opacity.value = p.opacity.value > 0 ? 0 : pJS.particles.opacity.value; }
                        for (const pocket of gravityPockets) { const dx=pocket.x-p.x, dy=pocket.y-p.y; if(dx*dx+dy*dy < pocket.radiusSq) { p.vx += dx * pocket.strength * 0.01; p.vy += dy * pocket.strength * 0.01; } }
                        
                        // Apply Player Interaction & Global Forces
                        if (!isPhased && !isStasis && !p.isCrystalized && !p.isEntangled) {
                            if (isLeftMouseDown) handleActivePower(p, i, pJS, universeProfile.leftClickPower, worldMouse);
                            if (isRightMouseDown) handleActivePower(p, i, pJS, universeProfile.rightClickPower, worldMouse);
                            for(const well of gravityWells) { const dx = well.x - p.x, dy = well.y - p.y; p.vx += dx * well.strength * 0.01; p.vy += dy * well.strength * 0.01; }
                        }
                        if(p.isInfected) { for(const p2 of pJS.particles.array) { if(p === p2 || p2.isInfected) continue; const dx=p.x-p2.x, dy=p.y-p2.y, dSq=dx*dx+dy*dy; if(dSq < Math.pow(p.radius+p2.radius+2, 2)) { p2.isInfected=true;p2.color={rgb:{r:255,g:50,b:50}}; } } }
                        
                        if (p.radius > p.radius_initial && !universeProfile.mutators.includes('Pulsing Particles')) { p.radius -= 0.05; }
                        p.vx *= friction; p.vy *= friction;

                        // Torus Field boundary check
                        if (universeProfile.mutators.includes('Torus Field')) {
                            if (p.x < 0) p.x = pJS.canvas.w; if (p.x > pJS.canvas.w) p.x = 0;
                            if (p.y < 0) p.y = pJS.canvas.h; if (p.y > pJS.canvas.h) p.y = 0;
                        }
                    }
                }
                
                // Entangled group physics
                entangledGroups.forEach((group, groupIndex) => { 
                    group.particles = group.particles.filter(p => p && pJS.particles.array.includes(p)); if(group.particles.length < 2) { entangledGroups.splice(groupIndex,1); return; }
                    let currentCX = 0, currentCY = 0; group.particles.forEach(p => { currentCX += p.x; currentCY += p.y; }); currentCX /= group.particles.length; currentCY /= group.particles.length;
                    group.particles.forEach((p, pIndex) => { const initialVec = group.initialVectors[pIndex]; if(!initialVec) return; const targetX = currentCX + initialVec.x, targetY = currentCY + initialVec.y; p.vx += (targetX - p.x) * 0.05; p.vy += (targetY - p.y) * 0.05; });
                });
                
                // Spawn new particles from white holes & quasars
                whiteHoles.forEach(h => { h.tick++; if (h.tick * h.spawnRate > 1 && pJS.particles.array.length < pJS.particles.number.value_max) { h.tick=0; pJS.fn.modes.pushParticles(1, {x:h.x, y:h.y}); } });
                quasars.forEach(q => { q.tick++; if (q.tick * q.spawnRate > 1 && pJS.particles.array.length < pJS.particles.number.value_max) { q.tick=0; pJS.fn.modes.pushParticles(2, {x:q.x, y:q.y}); const newPs = pJS.particles.array.slice(-2); newPs.forEach(p => { p.vx=Math.cos(q.angle)*q.strength*0.5; p.vy=Math.sin(q.angle)*q.strength*0.5; }); } });

                if (pJS.particles.array.length > pJS.particles.number.value_max) { pJS.particles.array.splice(0, pJS.particles.array.length - pJS.particles.number.value_max); }
                
                // --- Drawing & Final Update ---
                const ctx = pJS.canvas.ctx;
                nebulas.forEach(n => { const grad = ctx.createRadialGradient(n.x, n.y, n.radius/4, n.x, n.y, n.radius); grad.addColorStop(0, n.color.replace('0.15', '0.3')); grad.addColorStop(1, n.color.replace('0.15', '0')); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(n.x, n.y, n.radius, 0, 2*Math.PI); ctx.fill(); });
                pulsars.forEach(p => { p.angle += 0.05; ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, 2*Math.PI); ctx.fill(); for(let i=0; i<2; i++) { const angle = p.angle + i*Math.PI; const grad = ctx.createLinearGradient(p.x, p.y, p.x+Math.cos(angle)*1000, p.y+Math.sin(angle)*1000); grad.addColorStop(0, 'rgba(255,255,255,0.2)'); grad.addColorStop(1, 'rgba(255,255,255,0)'); ctx.strokeStyle=grad; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x+Math.cos(angle)*1000, p.y+Math.sin(angle)*1000); ctx.stroke(); } });
                quasars.forEach(q => { q.angle += q.rotationSpeed; ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(q.x, q.y, 10, 0, 2*Math.PI); ctx.fill(); for(let i=0; i<2; i++) { const angle = q.angle + i*Math.PI; const grad = ctx.createLinearGradient(q.x, q.y, q.x+Math.cos(angle)*1500, q.y+Math.sin(angle)*1500); grad.addColorStop(0, 'rgba(255,255,200,0.4)'); grad.addColorStop(1, 'rgba(255,255,200,0)'); ctx.strokeStyle=grad; ctx.lineWidth=4; ctx.beginPath(); ctx.moveTo(q.x, q.y); ctx.lineTo(q.x+Math.cos(angle)*1500, q.y+Math.sin(angle)*1500); ctx.stroke(); } });
                spacetimeRifts.forEach(r => { ctx.strokeStyle = `rgba(200,180,255,${0.5 + Math.sin(tick*0.05)*0.2})`; ctx.lineWidth=2; ctx.shadowColor = 'magenta'; ctx.shadowBlur = 15; ctx.beginPath(); r.points.forEach((p, i) => { if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x + (Math.random()-0.5)*5, p.y + (Math.random()-0.5)*5); }); ctx.stroke(); ctx.shadowBlur = 0; });
                blackHoles.forEach(h => { ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(h.x, h.y, h.eventHorizon, 0, 2*Math.PI); ctx.fill(); const grad = ctx.createRadialGradient(h.x,h.y,h.eventHorizon,h.x,h.y,h.eventHorizon+5); grad.addColorStop(0, 'rgba(255,200,100,0.8)'); grad.addColorStop(1, 'rgba(255,200,100,0)'); ctx.strokeStyle = grad; ctx.lineWidth = 2; ctx.stroke(); });
                whiteHoles.forEach(h => { ctx.fillStyle = `rgba(255,255,255,${0.5 + 0.5*Math.sin(tick*0.1)})`; ctx.beginPath(); ctx.arc(h.x, h.y, 10, 0, 2*Math.PI); ctx.fill(); });
                wormholes.forEach((w,i) => { w.life--; if(w.life <= 0) { wormholes.splice(i,1); return; } ctx.strokeStyle=`rgba(150, 100, 255, ${w.life/120})`; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(w.entry.x,w.entry.y,15,0,2*Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(w.exit.x,w.exit.y,15,0,2*Math.PI); ctx.stroke(); });
                phaseZones.forEach((z, i) => { z.life--; if (z.life <= 0) { phaseZones.splice(i, 1); } ctx.strokeStyle=`rgba(180, 200, 255, ${0.1 + (z.life / z.maxLife)*0.3})`; ctx.setLineDash([15, 10]); ctx.lineWidth=2; ctx.beginPath(); ctx.arc(z.x,z.y,Math.sqrt(z.radiusSq),0,2*Math.PI); ctx.stroke(); ctx.setLineDash([]); });
                stasisFields.forEach((f, i) => { f.life--; if (f.life <= 0) { stasisFields.splice(i, 1); } ctx.strokeStyle=`rgba(255, 255, 150, ${0.1 + (f.life / f.maxLife)*0.4})`; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(f.x, f.y, f.r * (0.95 + 0.05 * Math.sin(tick*0.1)), 0, 2*Math.PI); ctx.stroke(); });
                activeChords.forEach((c, i) => { c.life--; if(c.life <= 0) { activeChords.splice(i,1); return; } ctx.strokeStyle=`rgba(200,255,200,${c.life/c.maxLife})`; ctx.lineWidth=1; c.particles.forEach(p => { p.vx+=(Math.random()-0.5)*0.2; p.vy+=(Math.random()-0.5)*0.2; }); for(let j=0; j<c.particles.length; j++) { for (let k=j+1; k<c.particles.length; k++) { ctx.beginPath(); ctx.moveTo(c.particles[j].x, c.particles[j].y); ctx.lineTo(c.particles[k].x, c.particles[k].y); ctx.stroke(); }} });

                if (universeProfile.blueprintName === 'ChromaticAberration') {
                    const shift = Math.min(10, universeState.energy / 500);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.drawImage(pJS.canvas.el, shift, 0);
                    ctx.drawImage(pJS.canvas.el, -shift, 0);
                    ctx.globalCompositeOperation = 'source-over';
                }

                pJS.fn.particlesUpdate();
                pJS.fn.particlesDraw();
                
                requestAnimationFrame(update);
            };
            requestAnimationFrame(update);

            function handleActivePower(p, i, pJS, powerName, worldMouse) {
                const dx = worldMouse.x - p.x, dy = worldMouse.y - p.y;
                const distSq = dx*dx + dy*dy;
                const dist = Math.sqrt(distSq) || 1;

                switch(powerName) {
                    case 'comet': case 'symbiote': p.vx += dx * 0.01; p.vy += dy * 0.01; break;
                    case 'forceField': case 'sculptor': if (distSq < 200*200) { const f = -10/dist; p.vx += dx * f * 0.1; p.vy += dy * f * 0.1; } break;
                    case 'setOrbit': if (distSq < 200*200) { p.vx += dy * 0.015; p.vy -= dx * 0.015; } break;
                    case 'shaper': if (distSq < 150*150) { p.vx += dy * 0.01; p.vy -= dx * 0.01; } break;
                    case 'chainLightning': if (distSq < 200*200) { p.vx += (Math.random()-0.5)*0.5; p.vy += (Math.random()-0.5)*0.5; } break;
                    case 'void': if (distSq < 100*100) { if (p.radius > 0.5) p.radius -= 0.1; else pJS.particles.array.splice(i, 1); } break;
                    case 'scribe': if (distSq < 150*150) { const angle = Math.atan2(p.vy, p.vx), snappedAngle = Math.round(angle/(Math.PI/4))*(Math.PI/4), speed = Math.sqrt(p.vx*p.vx+p.vy*p.vy); p.vx = Math.cos(snappedAngle)*speed; p.vy = Math.sin(snappedAngle)*speed; } break;
                    case 'glaze': if (distSq < 100*100 && p.radius < 10) p.radius += 0.1; break;
                    case 'shatter': if (distSq < 150*150 && Math.random() > 0.9) { p.vx += (Math.random()-0.5)*1.5; p.vy += (Math.random()-0.5)*1.5; if (p.radius > 1) p.radius *= 0.95; } break;
                    case 'refractor': if (distSq < 200*200) { p.vx += (dy / dist) * 0.2; p.vy -= (dx / dist) * 0.2; } break;
                    case 'infect': if (distSq < 150*150) { p.isInfected = true; p.color = {rgb:{r:255,g:50,b:50}}; } break;
                    case 'tendril': if (distSq < 20*20 && pJS.particles.array.length < pJS.particles.number.value_max) { pJS.fn.modes.pushParticles(1, worldMouse); const newP = pJS.particles.array[pJS.particles.array.length-1]; newP.vx = p.vx; newP.vy = p.vy; } break;
                    case 'accelerate': if (distSq < 150*150) { p.vx *= 1.01; p.vy *= 1.01; } break;
                    case 'voidRift': if (distSq < 150*150) { p.radius -= 0.05; p.vx += dx/dist * 0.05; p.vy += dy/dist * 0.05; if(p.radius <= 0) pJS.particles.array.splice(i,1); } break;
                    case 'echoPulse': if(tick % 10 === 0) echoPulses.push({x: worldMouse.x, y: worldMouse.y, radiusSq: 250*250, maxLife: 120, life: 120}); break;
                    case 'phaseZone': if(tick % 10 === 0) phaseZones.push({x: worldMouse.x, y: worldMouse.y, radiusSq: 150*150, maxLife: 300, life: 300}); break;
                    case 'whisper': if (distSq < 200*200) { p.vx += dx * 0.001; p.vy += dy * 0.001; } break;
                    case 'fade': if (distSq < 150*150) { p.fading = 100; } break;
                    case 'paint': if (distSq < 150*150) { p.color = { rgb: {r: Math.random()*255, g: Math.random()*255, b: Math.random()*255 } }; p.colorLocked = true; } break;
                    case 'observe': if(distSq < 150*150){ p.vx *= 0.8; p.vy *= 0.8; if(p.radius < p.radius_initial*1.5) p.radius+=0.1; } break;
                    case 'quantumTunnel': if(distSq < 150*150 && Math.random()<0.01){p.x += (Math.random()-0.5)*80; p.y += (Math.random()-0.5)*80;} break;
                    case 'resonate': if(distSq < 150*150){ p.vx += Math.sin(tick*0.8+p.seed)*0.1; p.vy += Math.cos(tick*0.8+p.seed)*0.1; } break;
                    case 'dampen': if(distSq < 150*150){ p.vx *= 0.95; p.vy *= 0.95; } break;
                    case 'smudge': if(distSq < 150*150){ if(p.radius < 15) p.radius += 0.05; p.opacity.value = Math.max(0.1, p.opacity.value*0.99); } break;
                    case 'draw': if(distSq < 20*20 && pJS.particles.array.length < pJS.particles.number.value_max) { const newP = {...p, x: worldMouse.x+(Math.random()-0.5)*5, y: worldMouse.y+(Math.random()-0.5)*5}; pJS.particles.array.push(newP); tagParticles([newP]); } break;
                    case 'spore': if(distSq < 150*150 && pJS.particles.array.length < pJS.particles.number.value_max && Math.random()>0.95) { pJS.fn.modes.pushParticles(1, {x:p.x, y:p.y}); } break;
                    case 'sing': if (distSq < 150*150) { p.radius = p.radius_initial * (1 + 0.8 * Math.sin(tick * 0.5 + p.seed)); p.colorLocked = false; } break;
                    case 'rewind': if (distSq < 150*150) { p.vx *= -0.05; p.vy *= -0.05; } break;
                }
            }
            
            function handleClickPower(powerName, pJS, worldMouse) {
                switch(powerName) {
                    case 'supernova': for (const p of pJS.particles.array) { const dx=p.x-worldMouse.x, dy=p.y-worldMouse.y, dist = Math.sqrt(dx*dx+dy*dy)||1; if (dist < 250) { p.vx += dx/dist*30; p.vy += dy/dist*30; } } break;
                    case 'gravityWell': if (!gravityWells.some((w,i)=>{const dSq=Math.pow(w.x-worldMouse.x,2)+Math.pow(w.y-worldMouse.y,2); if(dSq<30*30){gravityWells.splice(i,1);return true;} return false;})) { gravityWells.push({x: worldMouse.x, y: worldMouse.y, strength: 0.2}); } break;
                    case 'toggleLinks': pJS.particles.line_linked.enable = !pJS.particles.line_linked.enable; pJS.fn.particlesRefresh(); break;
                    case 'harvest': for(let i=pJS.particles.array.length-1; i>=0; i--){ const p = pJS.particles.array[i], distSq = Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2); if(distSq < 100*100){ pJS.particles.array.splice(i,1); pJS.fn.modes.pushParticles(1,worldMouse); } } break;
                    case 'stasisField': stasisFields.push({x: worldMouse.x, y: worldMouse.y, r: 150, maxLife: 300, life: 300}); break;
                    case 'unravel': for(const p of pJS.particles.array) { if(Math.sqrt(Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2)) < 150) { p.unravelling = 120; } } break;
                    case 'glitch': for(const p of pJS.particles.array) { if(Math.sqrt(Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2)) < 100) { p.x = Math.random() * pJS.canvas.w; p.y = Math.random() * pJS.canvas.h; break; } } break;
                    case 'crystalize': for(const p of pJS.particles.array) { if(Math.sqrt(Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2)) < 150) { p.isCrystalized = true; p.color = {rgb:{r:200, g:220, b:255}}; } } break;
                    case 'wormhole': const exitPoint = { x: Math.random() * pJS.canvas.w, y: Math.random() * pJS.canvas.h }; wormholes.push({entry: {...worldMouse}, exit: exitPoint, life: 120}); for(const p of pJS.particles.array){ if(Math.sqrt(Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2)) < 100) { p.x = exitPoint.x + (Math.random()-0.5)*50; p.y = exitPoint.y + (Math.random()-0.5)*50; } } break;
                    case 'entangle': { const group = [], radiusSq = 150*150; let cX = 0, cY = 0; for (const p of pJS.particles.array) { const distSq = Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2); if (distSq < radiusSq && !p.isEntangled) { group.push(p); cX += p.x; cY += p.y; } } if (group.length > 1) { cX /= group.length; cY /= group.length; const newGroup = { particles: [], initialVectors: [] }; group.forEach(p => { p.isEntangled = true; p.colorLocked = true; p.color = {rgb:{r:180,g:255,b:180}}; newGroup.particles.push(p); newGroup.initialVectors.push({ x: p.x - cX, y: p.y - cY }); }); entangledGroups.push(newGroup); } break; }
                    case 'decohere': for (const p of pJS.particles.array) { if (Math.sqrt(Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2)) < 150) { p.isEntangled = false; p.vx += (Math.random()-0.5)*10; p.vy += (Math.random()-0.5)*10; } } break;
                    case 'shockwave': for (const p of pJS.particles.array) { const dx = p.x-worldMouse.x, dy=p.y-worldMouse.y, d = Math.sqrt(dx*dx+dy*dy)||1; if (d > 100 && d < 130) { p.vx += dx/d*30; p.vy += dy/d*30; } } break;
                    case 'silence': for (const p of pJS.particles.array) { if (Math.sqrt(Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2)) < 150) { p.vx = 0; p.vy = 0; } } break;
                    case 'splatter': pJS.fn.modes.pushParticles(15, worldMouse); const newParticles = pJS.particles.array.slice(-15); newParticles.forEach(p => { p.color = { rgb: {r: Math.random()*255, g: Math.random()*255, b: Math.random()*255 } }; tagParticles([p]); p.radius *= 1.5; }); break;
                    case 'blot': for(let i=pJS.particles.array.length-1; i>=0; i--){ const p = pJS.particles.array[i]; if(Math.sqrt(Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2)) < 100) pJS.particles.array.splice(i,1); } break;
                    case 'bloom': for(const p of pJS.particles.array) { if(Math.sqrt(Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2)) < 150) { p.blooming = 60; } } break;
                    case 'chord': { const group = []; for (const p of pJS.particles.array) { if(Math.sqrt(Math.pow(p.x-worldMouse.x,2)+Math.pow(p.y-worldMouse.y,2)) < 150) { group.push(p); if (group.length >= 5) break; } } if(group.length>1) activeChords.push({particles: group, maxLife: 180, life: 180}); break; }
                    case 'snapshot': stasisFields.push({x: worldMouse.x, y: worldMouse.y, r: 150, maxLife: 150, life: 150}); break;
                }
            }

            function triggerCataclysm(pJS) {
                cataclysmInProgress = true;
                ui.container.classList.remove('visible');
                ui.canvasContainer.classList.remove('shake');
                const choice = universeProfile.cataclysm;
                const regen = (delay) => setTimeout(() => generateUniverse(pJS, generateRandomSeed()), delay);

                switch(choice) {
                    case 'Supernova': for(const p of pJS.particles.array) { p.vx = (Math.random()-0.5)*50; p.vy = (Math.random()-0.5)*50; }; regen(2500); break;
                    case 'Phase Shift': pJS.particles.array.forEach(p => p.opacity.value = 0.1); pJS.fn.particlesRefresh(); regen(3000); break;
                    case 'Glitch Storm': let glitches = 0; const glitchInterval = setInterval(() => { glitches++; for(const p of pJS.particles.array) { p.x += (Math.random()-0.5)*20; p.y += (Math.random()-0.5)*20; if(Math.random() > 0.95) p.shape = ['circle', 'triangle', 'edge', 'star'][Math.floor(Math.random()*4)]; } if(glitches > 50) { clearInterval(glitchInterval); regen(1000); } }, 50); activeIntervals.push(glitchInterval); break;
                    case 'Resonance Cascade': let cascades = 0; const cascadeInterval = setInterval(() => { cascades++; for(let i=pJS.particles.array.length-1; i>=0; i--) { const p = pJS.particles.array[i]; p.radius += 0.5; if(p.radius > 40) { pJS.particles.array.splice(i,1); pJS.fn.modes.pushParticles(3, {x:p.x, y:p.y}); } } if(cascades > 100) { clearInterval(cascadeInterval); regen(1000); } }, 30); activeIntervals.push(cascadeInterval); break;
                    case 'Overgrowth': pJS.particles.line_linked.enable = true; let growths=0; const overgrowInterval = setInterval(() => { growths++; for(let i=0; i<5; i++) { if(pJS.particles.array.length < pJS.particles.number.value_max) { const p = pJS.particles.array[Math.floor(Math.random()*pJS.particles.array.length)]; pJS.fn.modes.pushParticles(1, {x:p.x,y:p.y}); }} if(growths > 60) { clearInterval(overgrowInterval); regen(2000); } }, 50); activeIntervals.push(overgrowInterval); break;
                    case 'Time Collapse': pJS.particles.array.forEach(p => { p.vx *= -1.5; p.vy *= -1.5; }); regen(3000); break;
                    case 'Total Annihilation': ui.canvasContainer.style.transition = 'filter 4s ease'; ui.canvasContainer.style.filter = 'brightness(0)'; regen(4500); break;
                    case 'Causality Collapse': let ccInterval = setInterval(() => { for(const p of pJS.particles.array) { p.vx += (p.startX - p.x) * 0.02; p.vy += (p.startY - p.y) * 0.02; if(p.radius > 0.1) p.radius -= 0.1; } }, 50); activeIntervals.push(ccInterval); setTimeout(() => { clearInterval(ccInterval); regen(1000); }, 4000); break;
                    case 'Great Fading': let fadeInterval = setInterval(() => { pJS.particles.array.forEach(p => p.opacity.value *= 0.95); }, 50); activeIntervals.push(fadeInterval); setTimeout(() => { clearInterval(fadeInterval); regen(1000);}, 4000); break;
                    case 'False Vacuum Decay': let decayBubble = {x: pJS.canvas.w/2, y: pJS.canvas.h/2, r: 0}; let decayInterval = setInterval(() => { decayBubble.r += pJS.canvas.w * 0.01; pJS.particles.array.forEach(p => { if(Math.pow(p.x-decayBubble.x,2)+Math.pow(p.y-decayBubble.y,2) < decayBubble.r*decayBubble.r) { p.vx*=-0.5; p.vy*=-0.5; p.color = {rgb:{r:255,g:100,b:255}};} }); if (decayBubble.r > pJS.canvas.w) { clearInterval(decayInterval); regen(1000); } }, 50); activeIntervals.push(decayInterval); break;
                    case 'The Great Silence': let silenceInterval = setInterval(() => { friction += 0.01; if (friction >= 1.2) { pJS.particles.array.forEach(p=>{p.vx=0;p.vy=0;}); clearInterval(silenceInterval); regen(2000); }}, 50); activeIntervals.push(silenceInterval); break;
                    case 'The Bleed': ui.body.classList.add('cataclysm-bleed'); pJS.particles.color.value = '#000000'; pJS.particles.move.trail.enable = true; pJS.fn.particlesRefresh(); regen(5000); break;
                    case 'The Grand Bloom': let bloomI = setInterval(() => { for(let i=pJS.particles.array.length-1; i>=0; i--){ const p = pJS.particles.array[i]; p.radius += 0.8; p.vx*=0.9; p.vy*=0.9; if(p.radius > 50){ pJS.particles.array.splice(i,1); if(pJS.particles.array.length < pJS.particles.number.value_max) pJS.fn.modes.pushParticles(5, {x:p.x,y:p.y}); }} if(pJS.particles.array.length === 0) {clearInterval(bloomI); regen(1000);}}, 50); activeIntervals.push(bloomI); break;
                    case 'The Final Chord': pJS.particles.array.forEach(p=>{p.vx=0;p.vy=0;}); ui.body.style.transition = 'background-color 2s'; ui.body.style.backgroundColor = '#fff'; setTimeout(() => regen(2000), 2000); break;
                    case 'Entropic Heat Death': let heatDeathI = setInterval(() => { friction = Math.min(1, friction + 0.001); pJS.particles.array.forEach(p=>p.opacity.value *= 0.99); if(pJS.particles.array[0] && pJS.particles.array[0].opacity.value < 0.01) { clearInterval(heatDeathI); regen(1000); } }, 50); activeIntervals.push(heatDeathI); break;
                }
            }
            
            ui.seed.addEventListener('click', () => { navigator.clipboard.writeText(window.location.href).then(() => { ui.seed.innerText = 'Copied!'; clearTimeout(seedCopyTimeout); seedCopyTimeout = setTimeout(() => ui.seed.innerText = `Seed: ${currentSeed}`, 2000); }); });
            window.addEventListener('mousemove', e => { mouse.x=e.clientX; mouse.y=e.clientY; ui.cursorGlow.style.left=`${e.clientX}px`; ui.cursorGlow.style.top=`${e.clientY}px`; });
            window.addEventListener('contextmenu', e => e.preventDefault());
            window.addEventListener('mousedown', e => { if (cataclysmInProgress) return; if (e.button === 0) isLeftMouseDown = true; else if (e.button === 2) isRightMouseDown = true; ui.cursorGlow.style.setProperty('--glow-color', `${pJS.particles.color.value}40`); ui.cursorGlow.classList.add('active'); });
            window.addEventListener('mouseup', e => {
                if (cataclysmInProgress) return;
                const powerName = e.button === 0 ? universeProfile.leftClickPower : universeProfile.rightClickPower;
                const clickPowers = ['supernova', 'gravityWell', 'stasisField', 'unravel', 'harvest', 'toggleLinks', 'glitch', 'crystalize', 'wormhole', 'entangle', 'decohere', 'shockwave', 'silence', 'splatter', 'blot', 'bloom', 'chord', 'snapshot'];
                if (clickPowers.includes(powerName)) { handleClickPower(powerName, pJS, mouse); }
                if (e.button === 0) isLeftMouseDown = false;
                else if (e.button === 2) isRightMouseDown = false;
                if(!isLeftMouseDown && !isRightMouseDown) ui.cursorGlow.classList.remove('active');
            });
            window.addEventListener('resize', () => { let resizeTimeout; clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => { if (pJS && currentSeed && !cataclysmInProgress) { isInitialLoad = true; generateUniverse(pJS, currentSeed); } }, 250); });

            function resetState(){ activeIntervals.forEach(clearInterval); clearTimeout(seedCopyTimeout); activeIntervals=[]; gravityWells=[]; stasisFields=[]; phaseZones=[]; echoPulses=[]; pulsars=[]; nebulas=[]; wormholes=[]; blackHoles=[]; whiteHoles=[]; cosmicStrings=[]; quasars=[]; spacetimeRifts=[]; gravityPockets=[]; timeDilationZones=[]; entangledGroups=[]; activeChords=[]; ui.canvasContainer.style.filter=''; ui.canvasContainer.style.transition = 'filter 1s ease'; ui.canvasContainer.classList.remove('shake'); ui.body.classList.remove('cataclysm-bleed'); ui.body.style.transition = ''; ui.body.style.backgroundColor = '#000'; tick=0; cataclysmInProgress=false; }
            function tagParticles(particles) { if (!particles) return; particles.forEach(p => { if (p) { if(p.radius_initial === undefined || isInitialLoad) p.radius_initial = p.radius; if(p.startX === undefined || isInitialLoad) { p.startX = p.x; p.startY = p.y; } if(universeProfile.mutators.includes('Dwarf & Giant')) { const newSize = Math.random() > 0.5 ? p.radius * 2 : p.radius * 0.5; p.radius = p.radius_initial = Math.max(1, newSize); } p.seed = Math.random() * 1000; p.isCrystalized = false; p.isInfected = false; p.unravelling = 0; p.fading = 0; p.colorLocked = false; p.isEntangled = false; p.blooming = 0; p.phasedFrames = 0; } }); }
            function setRandomGradient(hue, isMonochrome, seededRandom, isVoid) { const angle=Math.floor(seededRandom()*360); if(isVoid){ document.body.style.background=`linear-gradient(${angle}deg, #000000, #120510, #000000)`; } else if(isMonochrome){document.body.style.background=`linear-gradient(${angle}deg, hsl(${hue}, 80%, 10%), hsl(${hue}, 40%, 20%), hsl(${hue}, 90%, 5%))`;}else{document.body.style.background=`linear-gradient(${angle}deg, hsl(${hue},80%,30%), hsl(${(hue+120)%360},80%,20%), hsl(${(hue+240)%360},80%,25%))`;} ui.canvasContainer.style.background = document.body.style.background; ui.canvasContainer.style.backgroundSize = '400% 400%'; }
            function hslToHex(h,s,l){s/=100;l/=100;let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2,r=0,g=0,b=0;if(h<60){r=c;g=x}else if(h<120){r=x;g=c}else if(h<180){g=c;b=x}else if(h<240){g=x;b=c}else if(h<300){r=x;b=c}else{r=c;b=x}r=Math.round((r+m)*255).toString(16).padStart(2,'0');g=Math.round((g+m)*255).toString(16).padStart(2,'0');b=Math.round((b+m)*255).toString(16).padStart(2,'0');return`#${r}${g}${b}`; }
            function hexToRgb(hex) { var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }
        });
    </script>
</body>
</html>
