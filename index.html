<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="object-src 'none'; base-uri 'none'; require-trusted-types-for 'script';" />
    <title>Celestial Canvas</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            color: white;
            cursor: none;
        }

        body {
            background-color: #000;
            transition: background 1s ease, filter 0.5s ease;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transition: transform 2s cubic-bezier(0.76, 0, 0.24, 1), filter 1s ease, opacity 2s ease;
            background-size: 400% 400%;
            animation: gradientAnimation 30s ease infinite;
        }

        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #cursor-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.06) 0%, rgba(255, 255, 255, 0) 60%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            transition: all 0.2s ease-out;
        }
        
        #cursor-glow.active {
            width: 800px;
            height: 800px;
            background: radial-gradient(circle, var(--glow-color, rgba(255, 255, 255, 0.15)) 0%, rgba(255, 255, 255, 0) 50%);
        }

        #particles-js {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 2;
        }

        #seed-capture {
            position: fixed;
            bottom: 15px;
            left: 15px;
            z-index: 101;
            background-color: rgba(0,0,0,0.2);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: background-color 0.2s, opacity 0.5s;
            opacity: 0.8;
        }
        #seed-capture:hover {
            background-color: rgba(0,0,0,0.4);
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="particles-js"></div>
    </div>
    <div id="cursor-glow"></div>
    <div id="seed-capture" title="Click to copy shareable URL">Capture Seed</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/particles.js/2.0.0/particles.min.js"></script>
    <script>
        const baseConfig = { "particles": { "number": { "value": 150 }, "color": { "value": "#ffffff" }, "shape": { "type": "circle", "character": {"value": ["*"]} }, "opacity": { "value": 0.5, "random": true }, "size": { "value": 3, "random": true }, "line_linked": { "enable": false }, "move": { "enable": true, "speed": 4, "direction": "none", "straight": false, "out_mode": "out", "attract": { "enable": false }, "trail": {"enable": false, "fillColor": "#000", "length": 10} } }, "interactivity": { "detect_on": "canvas", "events": { "onhover": { "enable": true, "mode": "bubble" }, "resize": true }, "modes": { "bubble": { "distance": 200, "size": 8, "duration": 2 } } }, "retina_detect": true };

        document.addEventListener('DOMContentLoaded', () => {
            const cursorGlow = document.getElementById('cursor-glow');
            const seedCaptureUI = document.getElementById('seed-capture');
            const canvasContainer = document.getElementById('canvas-container');
            const friction = 0.98;
            let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
            let isLeftMouseDown = false, isRightMouseDown = false;
            let mouseDownTime = 0;
            let tick = 0;
            
            let universeState = { energy: 0, state: 'Stable' };
            let universeProfile = {};
            let gravityWells = [], voidPockets = [];
            let orbitalPoint = null;
            let currentSeed = '';
            let cataclysmInProgress = false;
            let isInitialLoad = true;
            let activeTimeouts = [];
            let seedCopyTimeout;

            // --- Seeding Engine ---
            function mulberry32(a) { return function() { var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
            function stringToSeed(str) { let h=0; for(let i=0;i<str.length;i++){h=(Math.imul(31,h)+str.charCodeAt(i))|0} return h; }
            function generateRandomSeed() { const w1 = ['COSMIC','ASTRAL','VOID','STAR','GALAXY','NEBULA','QUANTUM']; const w2 = ['DRIFT','ECHO','FLARE','PULSE','SONG','CHAOS','VORTEX']; return `${w1[Math.floor(Math.random()*w1.length)]}-${w2[Math.floor(Math.random()*w2.length)]}-${Math.floor(Math.random()*9000)+1000}`; }

            // --- Blueprint System ---
            const universeBlueprints = {
                Classical: { left:['comet','void'], right:['supernova','gravityWell'], events:['binaryStars','meteorShower'], cataclysms:['Supernova'], aesthetic:{glow:true, trails:false, shape:['circle','star'], physics:{attract:true, straight:false, random:true}} },
                Organic: { left:['symbiote','forceField'], right:['sculptor','setOrbit'], events:['pulsingCore'], cataclysms:['Phase Shift'], aesthetic:{glow:false, trails:true, shape:['circle'], physics:{attract:true, straight:false, random:true}} },
                Digital: { left:['chainLightning','shaper','scribe'], right:['glitch','toggleLinks'], events:['cosmicMessage'], cataclysms:['Glitch Storm'], aesthetic:{glow:true, trails:false, shape:['character'], chars:['0','1','<','>','/','?'], physics:{attract:false, straight:true, random:false}} },
                CosmicHorror: { left:['blackHole','symbiote'], right:['invert','anchor'], events:['greatContraction','voidPockets'], cataclysms:['The Great Collapse'], aesthetic:{glow:true, trails:false, shape:['edge'], monochrome:true, physics:{attract:false, straight:true, random:false}} },
                Painterly: { left:['alchemist','timeWarp'], right:['toggleTrails','spotlight'], events:['colorShift'], cataclysms:['Rift Storm'], aesthetic:{glow:false, trails:true, shape:['circle'], physics:{attract:false, straight:false, random:true}} }
            };

            const generateUniverse = (pJS, seed) => {
                resetState();
                currentSeed = seed;
                const seededRandom = mulberry32(stringToSeed(seed));
                
                const blueprintNames = Object.keys(universeBlueprints);
                const blueprintName = blueprintNames[Math.floor(seededRandom() * blueprintNames.length)];
                const blueprint = universeBlueprints[blueprintName];
                
                universeProfile = {
                    blueprintName,
                    leftClickPower: blueprint.left[Math.floor(seededRandom() * blueprint.left.length)],
                    rightClickPower: blueprint.right[Math.floor(seededRandom() * blueprint.right.length)],
                    ambientEvent: blueprint.events[Math.floor(seededRandom() * blueprint.events.length)],
                    cataclysm: blueprint.cataclysms[Math.floor(seededRandom() * blueprint.cataclysms.length)]
                };
                
                // Apply Aesthetics & Physics
                const baseHue = seededRandom() * 360;
                setRandomGradient(baseHue, blueprint.aesthetic.monochrome, seededRandom);
                pJS.particles.color.value = hslToHex((baseHue + 180) % 360, 80, 70);
                pJS.particles.number.value = blueprintName === 'Organic' ? 250 : 150;
                pJS.particles.move.speed = 1 + seededRandom() * 3;
                pJS.particles.move.trail.enable = !!blueprint.aesthetic.trails;
                pJS.particles.shape.type = blueprint.aesthetic.shape;
                if(pJS.particles.shape.type === 'character') pJS.particles.shape.character.value = blueprint.aesthetic.chars;
                pJS.particles.line_linked.enable = blueprintName === 'Digital' || universeProfile.leftClickPower === 'chainLightning';
                pJS.particles.move.attract.enable = blueprint.aesthetic.physics.attract;
                pJS.particles.move.straight = blueprint.aesthetic.physics.straight;
                pJS.particles.move.random = blueprint.aesthetic.physics.random;
                
                // Initialize State
                if (universeProfile.ambientEvent === 'voidPockets') { for(let i=0;i<3;i++) voidPockets.push({x:seededRandom()*window.innerWidth, y:seededRandom()*window.innerHeight, r:100+seededRandom()*100}); }
                if (universeProfile.ambientEvent === 'binaryStars') { gravityWells.push({x:window.innerWidth*0.25, y:window.innerHeight*0.5, strength:0.1}, {x:window.innerWidth*0.75, y:window.innerHeight*0.5, strength:0.1}); }
                
                universeState = { energy: 0, state: 'Stable', maxEnergy: 4000 + seededRandom() * 2000 };
                
                history.replaceState(null, '', `?seed=${currentSeed}`);
                seedCaptureUI.textContent = `Seed: ${currentSeed}`;
                seedCaptureUI.style.opacity = '0.8';
                
                pJS.fn.particlesRefresh();
                tagParticles(pJS.particles.array);

                if (isInitialLoad) {
                    pJS.particles.array.forEach(p => {
                        p.x = pJS.canvas.w / 2;
                        p.y = pJS.canvas.h / 2;
                        const angle = Math.random() * 2 * Math.PI;
                        const force = Math.random() * 20 + 5;
                        p.vx = Math.cos(angle) * force;
                        p.vy = Math.sin(angle) * force;
                    });
                    isInitialLoad = false;
                }
            };

            particlesJS('particles-js', baseConfig);
            const pJS = window.pJSDom[0].pJS;
            
            const urlParams = new URLSearchParams(window.location.search);
            generateUniverse(pJS, urlParams.get('seed') || generateRandomSeed());
            
            function getMouseInWorldSpace() {
                let worldMouse = { ...mouse };
                if (universeProfile.ambientEvent === 'greatContraction') {
                    const scale = 1 - (Math.sin(tick*0.001)*0.5 + 0.5)*0.1; 
                    const translateX = pJS.canvas.w / 2 * (1 - scale);
                    const translateY = pJS.canvas.h / 2 * (1 - scale);
                    worldMouse.x = (mouse.x - translateX) / scale;
                    worldMouse.y = (mouse.y - translateY) / scale;
                }
                return worldMouse;
            }

            // --- Main Update Loop ---
            const update = () => {
                tick++;
                if (cataclysmInProgress) { requestAnimationFrame(update); return; }

                if (isLeftMouseDown || isRightMouseDown) { universeState.energy += 10; } 
                else { universeState.energy = Math.max(0, universeState.energy - 5); }

                if (universeState.energy > universeState.maxEnergy && universeState.state !== 'Unstable') {
                    universeState.state = 'Unstable';
                    triggerCataclysm(pJS);
                } else if (universeState.energy > universeState.maxEnergy / 2) {
                    universeState.state = 'Energized';
                } else {
                    universeState.state = 'Stable';
                }
                
                const energyRatio = universeState.energy / universeState.maxEnergy;
                pJS.particles.move.speed = (1 + energyRatio * 5);
                document.querySelector('#particles-js').style.filter = universeState.state === 'Energized' ? `drop-shadow(0 0 5px ${pJS.particles.color.value})` : '';

                try {
                    // Handle canvas clearing for trails
                    if (pJS.particles.move.trail.enable) {
                        pJS.canvas.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        pJS.canvas.ctx.fillRect(0, 0, pJS.canvas.w, pJS.canvas.h);
                    } else {
                        pJS.canvas.ctx.clearRect(0, 0, pJS.canvas.w, pJS.canvas.h);
                    }
                    
                    const worldMouse = getMouseInWorldSpace();
                    let scale = 1;

                    // Handle Ambient Events
                    if (universeProfile.ambientEvent === 'greatContraction') { 
                        scale = 1 - (Math.sin(tick*0.001)*0.5 + 0.5)*0.1; 
                        pJS.canvas.ctx.save(); 
                        pJS.canvas.ctx.translate(pJS.canvas.w/2*(1-scale), pJS.canvas.h/2*(1-scale)); 
                        pJS.canvas.ctx.scale(scale, scale); 
                    }
                    if (universeProfile.ambientEvent === 'cosmicMessage' && tick === 300) { createMessage(pJS, ['CREATE','CHANGE','FEEL','BECOME'][Math.floor(Math.random()*4)]); }
                    if (universeProfile.ambientEvent === 'colorShift') { 
                        const newHue = (tick*0.1)%360;
                        const newHex = hslToHex(newHue, 80, 70);
                        const newRgb = pJS.fn.vendors.convertHexToRgb(newHex);
                        pJS.particles.color.value = newHex;
                        for(const p of pJS.particles.array) {
                            if (!p.colorLocked) { p.color = { rgb: newRgb }; }
                        }
                    }
                    if (universeProfile.ambientEvent === 'pulsingCore' && tick % 180 === 0) { for(const p of pJS.particles.array) { const dx=p.x-window.innerWidth/2; const dy=p.y-window.innerHeight/2; const dist=Math.sqrt(dx*dx+dy*dy)||1; p.vx+=dx/dist*5; p.vy+=dy/dist*5; } }
                    if (universeProfile.ambientEvent === 'meteorShower' && tick % 240 === 0 && Math.random() > 0.5) { createMeteorShower(pJS, mulberry32(stringToSeed(currentSeed))); }

                    // Particle Physics Loop
                    for(let i = pJS.particles.array.length - 1; i >= 0; i--) {
                        const p = pJS.particles.array[i];
                        if (!p) continue;
                        
                        let inVoidPocket = false;
                        for(const pocket of voidPockets){ const dx=pocket.x-p.x; const dy=pocket.y-p.y; if(Math.sqrt(dx*dx+dy*dy)<pocket.r){ inVoidPocket=true; break; } }
                        
                        if(!inVoidPocket) {
                            for(const well of gravityWells) { const dx=well.x-p.x; const dy=well.y-p.y; p.vx+=dx*well.strength*0.01; p.vy+=dy*well.strength*0.01; }
                            if(orbitalPoint) { const dx = orbitalPoint.x - p.x; const dy = orbitalPoint.y - p.y; p.vx += dx * 0.005; p.vy += dy * 0.005; }
                            if (isLeftMouseDown) handleActivePower(p, i, pJS, universeProfile.leftClickPower, worldMouse);
                            if (isRightMouseDown) handleActivePower(p, i, pJS, universeProfile.rightClickPower, worldMouse);
                        }
                        
                        if (p.radius > p.radius_initial) {
                           p.radius -= 0.05;
                        }

                        p.vx *= friction;
                        p.vy *= friction;
                    }
                    
                    // Draw Visual Indicators for invisible powers
                    const ctx = pJS.canvas.ctx;
                    voidPockets.forEach(pocket => {
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.strokeStyle = `rgba(255,255,255,${0.1 + Math.sin(tick * 0.02 + pocket.x) * 0.05})`;
                        ctx.lineWidth = 1 / scale;
                        ctx.beginPath();
                        ctx.arc(pocket.x, pocket.y, pocket.r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    });
                    gravityWells.forEach(well => {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1 / scale;
                        ctx.beginPath();
                        ctx.arc(well.x, well.y, 20 + Math.sin(tick * 0.05 + well.x) * 5, 0, Math.PI * 2);
                        ctx.stroke();
                    });
                    if (orbitalPoint) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.lineWidth = 2 / scale;
                        ctx.beginPath();
                        ctx.arc(orbitalPoint.x, orbitalPoint.y, 15, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(orbitalPoint.x, orbitalPoint.y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    pJS.fn.particlesUpdate();
                    pJS.fn.particlesDraw();
                } finally {
                    if (universeProfile.ambientEvent === 'greatContraction') {
                        pJS.canvas.ctx.restore();
                    }
                }
                requestAnimationFrame(update);
            };
            requestAnimationFrame(update);

            function handleActivePower(p, i, pJS, powerName, currentMouse) {
                const dx = currentMouse.x - p.x, dy = currentMouse.y - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;

                switch(powerName) {
                    case 'comet': case 'symbiote': case 'blackHole':
                        const attractStrength = powerName === 'blackHole' ? 0.3 : 0.1;
                        p.vx += dx * attractStrength; p.vy += dy * attractStrength;
                        if (powerName === 'blackHole' && dist < 150 && p.radius > 0.5) p.radius -= 0.1;
                        break;
                    case 'forceField': case 'sculptor':
                        if (dist < 200) { const f = -10/dist; p.vx += dx * f; p.vy += dy * f; }
                        break;
                    case 'shaper':
                        if (dist < 150) { p.vx += dy * 0.1; p.vy -= dx * 0.1; }
                        break;
                    case 'chainLightning':
                         if (dist < 200) { p.vx += (Math.random()-0.5)*5; p.vy += (Math.random()-0.5)*5; }
                        break;
                    case 'void':
                        if (dist < 100 && p.radius > 0.5) p.radius -= 0.1;
                        if (p.radius <= 0.5) pJS.particles.array.splice(i, 1);
                        break;
                    case 'scribe':
                        if (dist < 150) {
                            const angle = Math.atan2(p.vy, p.vx);
                            const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                            const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                            p.vx = Math.cos(snappedAngle) * speed;
                            p.vy = Math.sin(snappedAngle) * speed;
                        }
                        break;
                    case 'timeWarp': case 'anchor':
                        const slowFactor = powerName === 'anchor' ? 0.7 : 0.9;
                        if (dist < 150) { p.vx *= slowFactor; p.vy *= slowFactor; }
                        break;
                    case 'spotlight':
                        if (dist < 100 && p.radius < 10) p.radius += 0.1;
                        break;
                    case 'alchemist':
                        if (dist < 150) { 
                            p.color = { rgb: { r: Math.random()*255, g: Math.random()*255, b: Math.random()*255 } };
                            p.colorLocked = true;
                        }
                        break;
                }
            }
            
            function handleClickPower(powerName, pJS, currentMouse) {
                switch(powerName) {
                    case 'supernova':
                        for (const p of pJS.particles.array) {
                            const dx=p.x - currentMouse.x, dy=p.y - currentMouse.y, dist = Math.sqrt(dx*dx+dy*dy)||1;
                            if (dist < 250) { p.vx += dx/dist*30; p.vy += dy/dist*30; }
                        }
                        break;
                    case 'gravityWell':
                        let wellRemoved = false;
                        for (let i = gravityWells.length - 1; i >= 0; i--) {
                            const well = gravityWells[i];
                            const dx = currentMouse.x - well.x;
                            const dy = currentMouse.y - well.y;
                            if (Math.sqrt(dx * dx + dy * dy) < 30) {
                                gravityWells.splice(i, 1);
                                wellRemoved = true;
                                break;
                            }
                        }
                        if (!wellRemoved) {
                            gravityWells.push({x: currentMouse.x, y: currentMouse.y, strength: 0.2});
                        }
                        break;
                    case 'setOrbit':
                        if (orbitalPoint) {
                            const dx = currentMouse.x - orbitalPoint.x;
                            const dy = currentMouse.y - orbitalPoint.y;
                            if (Math.sqrt(dx * dx + dy * dy) < 20) { // Clicked near the existing point
                                orbitalPoint = null;
                            } else { // Clicked elsewhere, so move it
                                orbitalPoint = { x: currentMouse.x, y: currentMouse.y };
                            }
                        } else { // No point exists, create one
                            orbitalPoint = { x: currentMouse.x, y: currentMouse.y };
                        }
                        break;
                    case 'glitch':
                        for (const p of pJS.particles.array) {
                            const dx=p.x - currentMouse.x, dy=p.y - currentMouse.y, dist = Math.sqrt(dx*dx+dy*dy);
                            if (dist < 200) { p.x += (Math.random()-0.5)*100; p.y += (Math.random()-0.5)*100; }
                        }
                        break;
                    case 'toggleLinks':
                        pJS.particles.line_linked.enable = !pJS.particles.line_linked.enable;
                        break;
                    case 'toggleTrails':
                        pJS.particles.move.trail.enable = !pJS.particles.move.trail.enable;
                        break;
                    case 'invert':
                        for (const p of pJS.particles.array) {
                            const dx=p.x - currentMouse.x, dy=p.y - currentMouse.y, dist = Math.sqrt(dx*dx+dy*dy);
                            if (dist < 200) { p.vx *= -1; p.vy *= -1; }
                        }
                        break;
                }
            }

            function triggerCataclysm(pJS) {
                cataclysmInProgress = true;
                seedCaptureUI.style.opacity = '0';
                const choice = universeProfile.cataclysm;
                switch(choice) {
                    case 'The Great Collapse':
                        canvasContainer.style.transition = 'transform 3s cubic-bezier(0.83, 0, 0.17, 1)';
                        canvasContainer.style.transform = 'scale(0)';
                        setTimeout(() => { canvasContainer.style.transform = 'scale(1)'; generateUniverse(pJS, generateRandomSeed()); }, 4000);
                        break;
                    case 'Rift Storm': case 'Glitch Storm':
                        const isGlitch = choice === 'Glitch Storm';
                        canvasContainer.style.transition = 'filter 0.1s ease';
                        let stormInterval = setInterval(() => {
                           canvasContainer.style.filter = `blur(${Math.random()*10}px) ${isGlitch ? 'contrast(2)' : ''}`;
                           pJS.particles.array.forEach(p => { p.x += (Math.random()-0.5)*20; p.y += (Math.random()-0.5)*20; });
                        }, 100);
                        setTimeout(() => { clearInterval(stormInterval); canvasContainer.style.filter = ''; generateUniverse(pJS, generateRandomSeed()); }, 3000);
                        break;
                    case 'Phase Shift':
                        canvasContainer.style.transition = 'opacity 2s ease';
                        canvasContainer.style.opacity = '0';
                        setTimeout(() => { generateUniverse(pJS, generateRandomSeed()); canvasContainer.style.opacity = '1'; }, 2500);
                        break;
                    case 'Supernova':
                        for(const p of pJS.particles.array) { p.vx = (Math.random()-0.5)*50; p.vy = (Math.random()-0.5)*50; }
                        setTimeout(() => generateUniverse(pJS, generateRandomSeed()), 2500);
                        break;
                }
            }
            
            function clearActiveTimeouts() {
                activeTimeouts.forEach(clearTimeout);
                activeTimeouts = [];
            }
            
            // Event Listeners
            seedCaptureUI.addEventListener('click', () => { 
                navigator.clipboard.writeText(window.location.href).then(() => { 
                    seedCaptureUI.textContent = 'Copied!'; 
                    clearTimeout(seedCopyTimeout);
                    seedCopyTimeout = setTimeout(() => seedCaptureUI.textContent = `Seed: ${currentSeed}`, 2000); 
                }); 
            });
            window.addEventListener('mousemove', e => { mouse.x=e.clientX; mouse.y=e.clientY; cursorGlow.style.left=`${e.clientX}px`; cursorGlow.style.top=`${e.clientY}px`; });
            window.addEventListener('contextmenu', e => e.preventDefault());
            window.addEventListener('mousedown', e => {
                if (cataclysmInProgress) return;
                mouseDownTime = Date.now();
                if (e.button === 0) isLeftMouseDown = true;
                else if (e.button === 2) isRightMouseDown = true;
                cursorGlow.style.setProperty('--glow-color', `${pJS.particles.color.value}40`);
                cursorGlow.classList.add('active');
            });
            window.addEventListener('mouseup', e => {
                if (cataclysmInProgress) return;
                const holdDuration = Date.now() - mouseDownTime;
                
                if (e.button === 0) isLeftMouseDown = false;
                else if (e.button === 2) isRightMouseDown = false;
                
                const clickPowers = ['supernova', 'gravityWell', 'setOrbit', 'glitch', 'toggleLinks', 'invert', 'toggleTrails'];
                const destructivePowers = ['void', 'blackHole'];
                const powerName = e.button === 0 ? universeProfile.leftClickPower : universeProfile.rightClickPower;
                const worldMouse = getMouseInWorldSpace();

                if (clickPowers.includes(powerName)) {
                    handleClickPower(powerName, pJS, worldMouse);
                } else if (holdDuration < 200 && !destructivePowers.includes(powerName)) { // Only create particles on a short click for non-"click" and non-destructive powers
                    const oldLength = pJS.particles.array.length;
                    pJS.fn.modes.pushParticles(4, worldMouse);
                    const newParticles = pJS.particles.array.slice(oldLength);
                    tagParticles(newParticles);
                }
                
                if(!isLeftMouseDown && !isRightMouseDown) cursorGlow.classList.remove('active');
            });

            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (pJS && currentSeed && !cataclysmInProgress) {
                        generateUniverse(pJS, currentSeed);
                    }
                }, 250);
            });
            
            // Utility Functions
            function resetState(){ clearActiveTimeouts(); clearTimeout(seedCopyTimeout); gravityWells=[]; voidPockets=[]; orbitalPoint=null; document.body.style.filter=''; tick=0; cataclysmInProgress=false; }
            function tagParticles(particles) {
                if (!particles) return;
                particles.forEach(p => {
                    if (p && p.radius_initial === undefined) {
                        p.radius_initial = p.radius;
                    }
                });
            }
            function createMeteorShower(pJS, seededRandom) { const count=30,angle=seededRandom()*2*Math.PI,speed=seededRandom()*20+20; const startX=window.innerWidth/2-Math.cos(angle)*(window.innerWidth/2+100); const startY=window.innerHeight/2-Math.sin(angle)*(window.innerHeight/2+100); for(let i=0;i<count;i++){ const timeoutId = setTimeout(()=>{ const oldLength = pJS.particles.array.length; pJS.fn.modes.pushParticles(1,{x:startX+(seededRandom()-0.5)*200,y:startY+(seededRandom()-0.5)*200}); const newParticle = pJS.particles.array[oldLength]; if(newParticle){ tagParticles([newParticle]); newParticle.vx=Math.cos(angle)*speed;newParticle.vy=Math.sin(angle)*speed;}},i*20); activeTimeouts.push(timeoutId); } }
            function createMessage(pJS, message) { 
                clearActiveTimeouts(); 
                const fontSize=100, canvas=document.createElement('canvas'), ctx=canvas.getContext('2d'); 
                ctx.font = `${fontSize}px Arial`; 
                canvas.width = ctx.measureText(message).width; 
                canvas.height = fontSize; 
                ctx.font = `${fontSize}px Arial`; 
                ctx.fillStyle = "#FFF"; 
                ctx.fillText(message, 0, fontSize * 0.8); 
                const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data; 
                const startX = window.innerWidth / 2 - canvas.width / 2; 
                const startY = window.innerHeight / 2 - canvas.height / 2; 
                pJS.fn.particlesEmpty(); 
                const newParticles = []; 
                for(let y=0; y < canvas.height; y += 4) {
                    for(let x=0; x < canvas.width; x += 4) {
                        if (data[(x + y * canvas.width) * 4 + 3] > 128) {
                            const oldLength = pJS.particles.array.length;
                            pJS.fn.modes.pushParticles(1, { x: startX + x, y: startY + y });
                            const newParticle = pJS.particles.array[oldLength];
                            if(newParticle) newParticles.push(newParticle);
                        }
                    }
                } 
                tagParticles(newParticles); 
                const timeoutId = setTimeout(() => { pJS.fn.particlesRefresh(); tagParticles(pJS.particles.array); }, 5000); 
                activeTimeouts.push(timeoutId); 
            }
            function setRandomGradient(hue, isMonochrome, seededRandom) { const angle=Math.floor(seededRandom()*360); if(isMonochrome){document.body.style.background=`linear-gradient(${angle}deg, hsl(${hue}, 80%, 10%), hsl(${hue}, 40%, 20%), hsl(${hue}, 90%, 5%))`;}else{document.body.style.background=`linear-gradient(${angle}deg, hsl(${hue},80%,30%), hsl(${(hue+120)%360},80%,20%), hsl(${(hue+240)%360},80%,25%))`;} canvasContainer.style.background = document.body.style.background; canvasContainer.style.backgroundSize = '400% 400%'; }
            function hslToHex(h,s,l){s/=100;l/=100;let c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2,r=0,g=0,b=0;if(h<60){r=c;g=x}else if(h<120){r=x;g=c}else if(h<180){g=c;b=x}else if(h<240){g=x;b=c}else if(h<300){r=x;b=c}else{r=c;b=x}r=Math.round((r+m)*255).toString(16).padStart(2,'0');g=Math.round((g+m)*255).toString(16).padStart(2,'0');b=Math.round((b+m)*255).toString(16).padStart(2,'0');return`#${r}${g}${b}`; }
        });
    </script>
</body>
</html>
