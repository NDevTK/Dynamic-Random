/**
 * @file cataclysms.js
 * @description This file contains the logic for universe-ending cataclysms.
 */

import { ui, universeProfile, physics, setCataclysmInProgress, addActiveInterval, activeEffects } from './state.js';
import { generateUniverse } from './universe.js';

/**
 * Triggers a universe-ending cataclysm.
 * @param {object} pJS - The particles.js instance.
 */
export function triggerCataclysm(pJS) {
    setCataclysmInProgress(true);
    ui.container.classList.remove('visible');
    ui.canvasContainer.classList.remove('shake');
    const choice = universeProfile.cataclysm;
    const regen = (delay) => setTimeout(() => generateUniverse(pJS, null, true), delay);

    switch(choice) {
        case 'Supernova': for(const p of pJS.particles.array) { p.vx = (Math.random()-0.5)*50; p.vy = (Math.random()-0.5)*50; }; regen(2500); break;
        case 'Phase Shift': pJS.particles.array.forEach(p => p.opacity.value = 0.1); pJS.fn.particlesRefresh(); regen(3000); break;
        case 'Glitch Storm': let glitches = 0; const glitchInterval = setInterval(() => { glitches++; for(const p of pJS.particles.array) { p.x += (Math.random()-0.5)*20; p.y += (Math.random()-0.5)*20; if(Math.random() > 0.95) p.shape = ['circle', 'triangle', 'edge', 'star'][Math.floor(Math.random()*4)]; } if(glitches > 50) { clearInterval(glitchInterval); regen(1000); } }, 50); addActiveInterval(glitchInterval); break;
        case 'Resonance Cascade': let cascades = 0; const cascadeInterval = setInterval(() => { cascades++; for(let i=pJS.particles.array.length-1; i>=0; i--) { const p = pJS.particles.array[i]; p.radius += 0.5; if(p.radius > 40) { pJS.particles.array.splice(i,1); pJS.fn.modes.pushParticles(3, {x:p.x, y:p.y}); } } if(cascades > 100) { clearInterval(cascadeInterval); regen(1000); } }, 30); addActiveInterval(cascadeInterval); break;
        case 'Overgrowth': pJS.particles.line_linked.enable = true; let growths=0; const overgrowInterval = setInterval(() => { growths++; for(let i=0; i<5; i++) { if(pJS.particles.array.length < pJS.particles.number.value_max) { const p = pJS.particles.array[Math.floor(Math.random()*pJS.particles.array.length)]; pJS.fn.modes.pushParticles(1, {x:p.x,y:p.y}); }} if(growths > 60) { clearInterval(overgrowInterval); regen(2000); } }, 50); addActiveInterval(overgrowInterval); break;
        case 'Time Collapse': pJS.particles.array.forEach(p => { p.vx *= -1.5; p.vy *= -1.5; }); regen(3000); break;
        case 'Total Annihilation': ui.canvasContainer.style.transition = 'filter 4s ease'; ui.canvasContainer.style.filter = 'brightness(0)'; regen(4500); break;
        case 'Causality Collapse': let ccInterval = setInterval(() => { for(const p of pJS.particles.array) { p.vx += (p.startX - p.x) * 0.02; p.vy += (p.startY - p.y) * 0.02; if(p.radius > 0.1) p.radius -= 0.1; } }, 50); addActiveInterval(ccInterval); setTimeout(() => { clearInterval(ccInterval); regen(1000); }, 4000); break;
        case 'Great Fading': let fadeInterval = setInterval(() => { pJS.particles.array.forEach(p => p.opacity.value *= 0.95); }, 50); addActiveInterval(fadeInterval); setTimeout(() => { clearInterval(fadeInterval); regen(1000);}, 4000); break;
        case 'False Vacuum Decay': let decayBubble = {x: pJS.canvas.w/2, y: pJS.canvas.h/2, r: 0}; let decayInterval = setInterval(() => { decayBubble.r += pJS.canvas.w * 0.01; pJS.particles.array.forEach(p => { if(Math.pow(p.x-decayBubble.x,2)+Math.pow(p.y-decayBubble.y,2) < decayBubble.r*decayBubble.r) { p.vx*=-0.5; p.vy*=-0.5; p.color = {rgb:{r:255,g:100,b:255}};} }); if (decayBubble.r > pJS.canvas.w) { clearInterval(decayInterval); regen(1000); } }, 50); addActiveInterval(decayInterval); break;
        case 'The Great Silence': let silenceInterval = setInterval(() => { physics.friction += 0.01; if (physics.friction >= 1.2) { pJS.particles.array.forEach(p=>{p.vx=0;p.vy=0;}); clearInterval(silenceInterval); regen(2000); }}, 50); addActiveInterval(silenceInterval); break;
        case 'The Bleed': ui.body.classList.add('cataclysm-bleed'); pJS.particles.color.value = '#000000'; pJS.particles.move.trail.enable = true; pJS.fn.particlesRefresh(); regen(5000); break;
        case 'UnseenGibbering': let gibber = 0; const gibberInterval = setInterval(() => { gibber++; for(const p of pJS.particles.array) { p.vx += (Math.random()-0.5)*2; p.vy += (Math.random()-0.5)*2; if (Math.random() > 0.99) pJS.particles.array.splice(pJS.particles.array.indexOf(p), 1); } if(gibber > 150) { clearInterval(gibberInterval); regen(1000); } }, 20); addActiveInterval(gibberInterval); break;
        case 'CanvasWipe': let wipe = 0; const wipeInterval = setInterval(() => { wipe++; pJS.particles.array.forEach(p => { p.colorLocked = false; p.color = {rgb:{r:255,g:255,b:255}}; p.opacity.value *= 0.9; }); if(wipe > 100) { clearInterval(wipeInterval); regen(1000); } }, 20); addActiveInterval(wipeInterval); break;
        case 'CoreEruption': pJS.particles.array.forEach(p => { const dx=p.x-pJS.canvas.w/2, dy=p.y-pJS.canvas.h/2, dist=Math.sqrt(dx*dx+dy*dy)||1; p.vx = dx/dist * (20 + Math.random()*20); p.vy = dy/dist * (20 + Math.random()*20); p.color = {rgb:{r:255,g:50,b:0}}; }); regen(3000); break;
        case 'DeepFreeze': physics.friction = 1.05; pJS.particles.array.forEach(p => { p.color = {rgb:{r:200,g:220,b:255}}; }); setTimeout(() => { pJS.particles.array.forEach(p => { p.vx += (Math.random()-0.5)*5; p.vy += (Math.random()-0.5)*5; if(p.radius > 1) p.radius *= 0.5; }); }, 2500); regen(3500); break;
        case 'HiveCollapse': let collapses = 0; const collapseInterval = setInterval(() => { collapses++; for(let i=pJS.particles.array.length-1; i>=0; i--) { const p = pJS.particles.array[i]; p.vx += (pJS.canvas.w/2 - p.x) * 0.005; p.vy += (pJS.canvas.h/2 - p.y) * 0.005; if(Math.random() > 0.9) pJS.particles.array.splice(i,1); } if(collapses > 120) { clearInterval(collapseInterval); regen(1000); } }, 30); addActiveInterval(collapseInterval); break;
        case 'ForbiddenRitual': const ritualCenter = {x: pJS.canvas.w/2, y: pJS.canvas.h/2}; let ritual = 0; const ritualInterval = setInterval(() => { ritual++; pJS.particles.array.forEach(p => { const dx = ritualCenter.x - p.x, dy = ritualCenter.y - p.y, dist=Math.sqrt(dx*dx+dy*dy); p.vx += dx * 0.003; p.vy += dy * 0.003; p.vx *= 0.98; p.vy *= 0.98; if (dist < 50) {p.vx=0;p.vy=0;} p.color = {rgb:{r:200,g:50,b:255}}; }); if(ritual > 200) { pJS.particles.array.forEach(p => { p.vx = (Math.random()-0.5)*50; p.vy = (Math.random()-0.5)*50; }); clearInterval(ritualInterval); regen(2000); } }, 20); addActiveInterval(ritualInterval); break;
        case 'ProtoStarCollapse': pJS.particles.array.forEach(p => { p.vx += (pJS.canvas.w/2 - p.x)*0.01; p.vy += (pJS.canvas.h/2 - p.y)*0.01; }); setTimeout(() => { pJS.particles.array.forEach(p => { const dx=p.x-pJS.canvas.w/2, dy=p.y-pJS.canvas.h/2, d=Math.sqrt(dx*dx+dy*dy)||1; p.vx = dx/d*30; p.vy = dy/d*30; }); }, 3000); regen(4000); break;
        case 'BenthicStorm': let storm = 0; const stormInterval = setInterval(() => { storm++; physics.friction = 0.7; pJS.particles.array.forEach(p => { p.vx += (Math.random()-0.5)*2; p.vy += (Math.random()-0.5)*2; }); if(storm > 100) { clearInterval(stormInterval); regen(1000); } }, 50); addActiveInterval(stormInterval); break;
        case 'SystemCrash': ui.body.style.background = '#000'; pJS.particles.array.forEach(p => { p.vx=0; p.vy=0; p.shape='character'; p.character = {value:['!','@','#','$','%']}; }); pJS.fn.particlesRefresh(); regen(3000); break;
        case 'Decomposition': let decomp = 0; const decompInterval = setInterval(() => { decomp++; if(pJS.particles.array.length > 0) pJS.particles.array.splice(0, 5); if(decomp > 100) { clearInterval(decompInterval); regen(1000); } }, 50); addActiveInterval(decompInterval); break;
        case 'Shattering': pJS.particles.array.forEach(p => { p.vx = (Math.random()-0.5)*15; p.vy = (Math.random()-0.5)*15; if (p.radius > 1) p.radius *= 0.5; }); regen(2000); break;
        case 'PaperTearCataclysm': let tear = pJS.canvas.w/2; let tearInterval = setInterval(() => { tear += 10; for(let i=pJS.particles.array.length-1; i>=0; i--) { if(Math.abs(pJS.particles.array[i].x - tear) < 10) pJS.particles.array.splice(i,1); } if(tear > pJS.canvas.w) { clearInterval(tearInterval); regen(1000); } }, 20); addActiveInterval(tearInterval); break;
        case 'ColorBurn': let burn = 0; const burnInterval = setInterval(() => { burn++; pJS.particles.array.forEach(p => { const c = p.color.rgb; p.color.rgb = {r:Math.min(255, c.r+5), g:Math.max(0, c.g-2), b:Math.max(0, c.b-2)}; }); if(burn > 100) { clearInterval(burnInterval); regen(1000); } }, 30); addActiveInterval(burnInterval); break;
        case 'WebCollapse': activeEffects.silkThreads.forEach(t => { t.life = 1; }); let webCollapse = 0; const webCollapseInterval = setInterval(() => { webCollapse++; activeEffects.silkThreads.forEach(t => { const midX = (t.p1.x+t.p2.x)/2, midY = (t.p1.y+t.p2.y)/2; t.p1.vx += (midX - t.p1.x) * 0.01; t.p1.vy += (midY - t.p1.y) * 0.01; t.p2.vx += (midX - t.p2.x) * 0.01; t.p2.vy += (midY - t.p2.y) * 0.01; }); if(webCollapse > 150) { clearInterval(webCollapseInterval); regen(1000); } }, 20); addActiveInterval(webCollapseInterval); break;
        case 'GrandCooling': let cooling = 0; const coolInterval = setInterval(() => { cooling++; physics.friction *= 1.01; pJS.particles.array.forEach(p => { const c = p.color.rgb; p.color.rgb = {r:c.r*0.99, g:c.g*0.99, b:Math.min(255, c.b+1)}; }); if(cooling > 200) { clearInterval(coolInterval); regen(1000); } }, 20); addActiveInterval(coolInterval); break;
        case 'BigRip': let rip = 0; const ripInterval = setInterval(() => { rip++; pJS.particles.array.forEach(p => { p.vx *= 1.05; p.vy *= 1.05; p.radius *= 0.99; if(p.radius < 0.1) pJS.particles.array.splice(pJS.particles.array.indexOf(p), 1); }); if(rip > 150 || pJS.particles.array.length === 0) { clearInterval(ripInterval); regen(1000); } }, 20); addActiveInterval(ripInterval); break;
        case 'Homogenization': let homo = 0; const homoInterval = setInterval(() => { homo++; const avg_c = pJS.particles.array.reduce((acc, p) => { acc.r += p.color.rgb.r; acc.g += p.color.rgb.g; acc.b += p.color.rgb.b; return acc; }, {r:0,g:0,b:0}); avg_c.r /= pJS.particles.array.length; avg_c.g /= pJS.particles.array.length; avg_c.b /= pJS.particles.array.length; pJS.particles.array.forEach(p => { p.vx *= 0.95; p.vy *= 0.95; p.color.rgb.r = (p.color.rgb.r*9 + avg_c.r)/10; p.color.rgb.g = (p.color.rgb.g*9 + avg_c.g)/10; p.color.rgb.b = (p.color.rgb.b*9 + avg_c.b)/10; }); if(homo > 200) { clearInterval(homoInterval); regen(1000); } }, 20); addActiveInterval(homoInterval); break;
        case 'Banishing': pJS.particles.array.forEach(p => { p.vx = (Math.random()-0.5)*5; p.vy = (Math.random()-0.5)*5 - 20; p.opacity.value = 1; }); regen(4000); break;
        case 'TidalWave': let wavePos = -100; const waveInterval = setInterval(() => { wavePos += 20; pJS.particles.array.forEach(p => { if (p.x < wavePos && p.x > wavePos - 40) { p.vx += 15; p.vy += (Math.random() - 0.5) * 5; } }); if (wavePos > pJS.canvas.w + 100) { clearInterval(waveInterval); regen(1000); } }, 20); addActiveInterval(waveInterval); break;
    }
}